<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title type="html">Rubinius Blog</title>
  <link rel="self" type="application/atom+xml" href="http://rubini.us/feed/atom.xml" />
  <link rel="alternate" type="text/html" href="http://rubini.us/blog" />
  <id>http://rubini.us/</id>
  <updated>2014-10-29T00:40:18-05:00</updated>

  
  <entry>
    <title type="html">Happy 2014!</title>
    <id>http://rubini.us/2014/01/06/happy-2014/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2014/01/06/happy-2014/" />
    <updated>2014-01-06T00:00:00-06:00</updated>
    <author>
      <name>Brian Shirai</name>
    </author>
    
    <content type="html">&lt;p&gt;New beginnings are exciting and I'm delighted to announce that I've joined a
terrific team of people at &lt;a href=&quot;http://enova.com&quot;&gt;Enova&lt;/a&gt; who are working hard to
innovate and push Ruby well beyond its comfort zone.&lt;/p&gt;

&lt;p&gt;I'm looking forward to sharing the journey with you as we build fantastic
developer tools, migrate giant monolithic Rails apps, and create
next-generation distributed applications that scale efficiently to &lt;em&gt;all the
cores&lt;/em&gt;. There are huge challenges given the engineering tasks, but also
tremendous opportunities to demonstrate how powerful Ruby is and can be.&lt;/p&gt;

&lt;p&gt;At Enova, I'll be continuing my OSS work on Rubinius and RubySpec. This is a
generous contribution from Enova to the Ruby community. I'll also be devoting
time to Rubinius X as we explore and address the many deficiencies in Ruby
that continue to drive developers and businesses to other languages like Go,
Clojure, and Node.js.&lt;/p&gt;

&lt;p&gt;For those still running on Ruby 1.8.7, we'd love for you to collaborate with
us as we build tools to migrate to newer Ruby versions. If you're already on
Ruby 1.9.3 or later, we'd love to help you explore migrating from MRI to a
Ruby implementation with a modern garbage collector, JIT compiler, and good
support for concurrency. If you're considering rewriting your Ruby app in some
other language, please let us know why.&lt;/p&gt;

&lt;p&gt;If you've already rewritten your Ruby apps in another language, I'd especially
like to hear from you. Rewrites always involve new architecture decisions as
well. I'd like to understand if the Ruby &lt;em&gt;language&lt;/em&gt; prevented your new
architecture decisions or if better technology in Ruby would have saved the
cost of rewriting an application.&lt;/p&gt;

&lt;p&gt;Kumiko, Miwa, and I will be moving to Chicago. If you're in the area, we look
forward to meeting you. If not, hopefully you'll come visit Chicago and say
hello, maybe at &lt;a href=&quot;http://lanyrd.com/2014/railsconf/&quot;&gt;RailsConf 2014&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;Happy New Year!&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Testing Your Project with Rubinius on Travis</title>
    <id>http://rubini.us/2013/12/03/testing-with-rbx-on-travis/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2013/12/03/testing-with-rbx-on-travis/" />
    <updated>2013-12-03T00:00:00-06:00</updated>
    <author>
      <name>Brian Shirai</name>
    </author>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;http://travis-ci.org&quot;&gt;Travis CI&lt;/a&gt; has been a tremendously useful tool for
automating testing and has provided Ruby implementations with valuable
feedback. However, it can be a trial-and-error process to find the right
incantations for &lt;code&gt;.travis.yml&lt;/code&gt; to get your preferred selection of Ruby
implementations running. This post explains how to test your project on
Rubinius.&lt;/p&gt;

&lt;p&gt;With the Rubinius 2.0 release, there are no longer language modes. Rubinius is
presently working on compatibility with the upcoming MRI 2.1 release. There
are still compatibility issues to be fixed, primarily keyword syntax and some
core library API changes. What this means for your &lt;code&gt;.travis.yml&lt;/code&gt; file is that
'rbx-18mode' and 'rbx-19mode' are no longer supported. We submitted a patch to
the &lt;a href=&quot;https://github.com/travis-ci/travis-lint&quot;&gt;Travis lint tool&lt;/a&gt; to check for
this, so please use the linter!&lt;/p&gt;

&lt;p&gt;So, if those language modes are no longer available, what should you add to
your &lt;code&gt;.travis.yml&lt;/code&gt; file? Remember that Rubinius is releasing new versions every
week or so. Together with recent changes to RVM, this gives four options for
how specific you want to be about the Rubinius version you test against. The
following list of Rubinius options is from least-to-most specific:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;'rbx' - This means the most recent Rubinius release. Every time your tests
run, the most recently released binary will be used.&lt;/li&gt;
&lt;li&gt;'rbx-X' - This means the most recent Major release. For example, if you use
'rbx-2' (which is the only one available right now), your tests will run on
the most recent 2.Y.Z release, but would not run on 3.Y.Z.&lt;/li&gt;
&lt;li&gt;'rbx-X.Y' - This means the most recent Minor release. If you use 'rbx-2.2',
your tests will run on the most recent 2.2.Z release, but will not use the
2.3.Z or 2.1.Z release.&lt;/li&gt;
&lt;li&gt;'rbx-X.Y.Z' - This means precisely the specified release. So, 'rbx-2.2.1'
will run only on the 2.1.1 releease and no other release.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;This method of designating the version of Rubinius you wish to run against
should look similar to specifying versions of gems with the pessimistic
operator (~&gt;). It is intended to give you the same flexibility while allowing
for stability constraints that you choose.&lt;/p&gt;

&lt;p&gt;Since each of these designations is independent, you can mix and match them as
you wish. For example, if you know that Rubinius 2.2.1 is green for your
project, you can specify both 'rbx-2.2.1' and 'rbx'. Or you can always stay on
the cutting edge by just using 'rbx'.&lt;/p&gt;

&lt;p&gt;If you need help getting your project set up or updated on Travis, please let
us know. I've created a simple project called
&lt;a href=&quot;https://travis-ci.org/rubinius/travis-canary&quot;&gt;travis-canary&lt;/a&gt; that you can
check to see if the ways of specifying Rubinius listed above are currently
working on Travis.&lt;/p&gt;

&lt;p&gt;Happy testing!&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">The Parisian Release</title>
    <id>http://rubini.us/2013/10/18/the-parisian-release/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2013/10/18/the-parisian-release/" />
    <updated>2013-10-18T00:00:00-05:00</updated>
    <author>
      <name>Brian Shirai</name>
    </author>
    
    <content type="html">&lt;p&gt;Rubinius 2.1.0 has been released. I'm naming this &quot;The Parisian release&quot; in
honor of the &lt;a href=&quot;http://www.dotrb.eu/&quot;&gt;dotRB conference&lt;/a&gt; in Paris and today being
Evan's birthday. I wanted this to be the 2.0 release, but circumstances, so
sorry about that.&lt;/p&gt;

&lt;p&gt;Following the release scheme I detailed in the &lt;a href=&quot;http://rubini.us/2013/10/04/rubinius-2-0-released/&quot;&gt;2.0
release&lt;/a&gt;, I've rev'd the
minor version because we added a few C-API functions and different standard
library loading stubs. The rest of the changes are basically bug fixes.&lt;/p&gt;

&lt;p&gt;I'll be posting more soon about gems, packaging, and releases.&lt;/p&gt;

&lt;p&gt;Enjoy! Preferably with a glass of nice wine but surely with something that
makes you happy.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Introducing Rubinius X</title>
    <id>http://rubini.us/2013/10/15/introducing-rubinius-x/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2013/10/15/introducing-rubinius-x/" />
    <updated>2013-10-15T00:00:00-05:00</updated>
    <author>
      <name>Brian Shirai</name>
    </author>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;ED: Removed a &lt;a href=&quot;https://twitter.com/reinh/status/390544258899664896&quot;&gt;&quot;frequently misused English
phrase&quot;&lt;/a&gt; to improve
readability.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Today, I'm announcing the &lt;a href=&quot;http://x.rubini.us&quot;&gt;Rubinius X&lt;/a&gt; project. Please read
about the details at the website. Here's why I started the project.&lt;/p&gt;

&lt;p&gt;Ruby is a dying language. Business is over its dalliance with Ruby. No major
startup is lauding their use of Ruby and existing businesses are migrating away
or simply writing new applications in a different language.&lt;/p&gt;

&lt;p&gt;Businesses care about providing customers value so the businesses earn profits.
That's the harsh reality. Ruby is failing to help businesses engage customers.
It is seen as inefficient and inferior to other languages.&lt;/p&gt;

&lt;p&gt;It's not true that people are leaving Ruby because the language is no longer
new. Javascript is not new and it's not a particularly good language. People
use it because it helps them solve problems. Java is also not new and many
people dislike writing Java code. But Java is evolving and businesses pay a lot
of people to write Java. No business is rewriting their Java applications in
Ruby because the developers are happier.&lt;/p&gt;

&lt;p&gt;Ruby has great potential to help businesses compete in tumultuous markets by
reducing the cost to experiment with products that may interest consumers. It
has &lt;em&gt;potential&lt;/em&gt; but fundamental things about Ruby must change. Simply writing
some libraries or a new framework like Rails isn't enough.&lt;/p&gt;

&lt;p&gt;I &lt;em&gt;really&lt;/em&gt; want Ruby to be a language that businesses choose so that people who
are happy writing Ruby will have a job. I'm going to test whether this is
possible and I hope you will help.&lt;/p&gt;

&lt;p&gt;I want to thank a number of people who have inspired me: &lt;a href=&quot;https://twitter.com/wycats&quot;&gt;Yehuda
Katz&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/jcoglan&quot;&gt;James Coglan&lt;/a&gt;,
&lt;a href=&quot;https://twitter.com/garybernhardt&quot;&gt;Gary Bernhardt&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/evanphx&quot;&gt;Evan
Phoenix&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/defiler&quot;&gt;Wilson
Bilkovich&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/richhickey&quot;&gt;Rich
Hickey&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/mrb_bk&quot;&gt;Michael
Bernstein&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/gpxl&quot;&gt;Gerlando
Piro&lt;/a&gt;, and many other.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">The Once and Future Rubinius</title>
    <id>http://rubini.us/2013/10/11/the-once-and-future-rubinius/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2013/10/11/the-once-and-future-rubinius/" />
    <updated>2013-10-11T00:00:00-05:00</updated>
    <author>
      <name>Brian Shirai</name>
    </author>
    
    <content type="html">&lt;p&gt;Engine Yard has &lt;a href=&quot;https://blog.engineyard.com/2013/the-future-of-rubinius&quot;&gt;posted their
statement&lt;/a&gt; about
ending sponsorship for Rubinius, which gives me the opportunity to clearly
address the future of Rubinius.&lt;/p&gt;

&lt;p&gt;First of all, Engine Yard deserves great respect and admiration for their
contribution to Rubinius and the entire Ruby community. I had the pleasure of
interacting often with three of the Engine Yard founders: Tom Mornini, Lance
Walley, and Ezra Zygmuntowicz. I have rarely had the good fortune to work with
people as ethical, careful, and visionary as these folks. They endeavored to
build community &lt;em&gt;and&lt;/em&gt; business together, and they were highly influential in
both.&lt;/p&gt;

&lt;p&gt;Engine Yard's sponsorship of Rubinius certainly accelerated development and
brought the project to the attention of many developers. Additionally, Engine
Yard's sponsorship contributed to the success of
&lt;a href=&quot;http://rubyspec.org&quot;&gt;RubySpec&lt;/a&gt; as an idea and tool for unifying Ruby
compatibility across more than a half-dozen significant implementations of Ruby
for the benefit of the Ruby community.&lt;/p&gt;

&lt;p&gt;So, thank you very much, Engine Yard!&lt;/p&gt;

&lt;p&gt;The simplest statement about the status of Rubinius is that there are now zero
people paid to work on the project. This fact has several implications, none of
which are inherently negative.&lt;/p&gt;

&lt;p&gt;On the one hand, Rubinius is free to aggressively pursue  the goals of the
project in helping build the future of Ruby. On the other hand, I have
significantly less time to devote to the project. While unfortunate, I'm not
discouraged. I worked on Rubinius for over a year before Engine Yard hired me
and we accomplished a tremendous amount.&lt;/p&gt;

&lt;p&gt;We still have numerous things yet to do. Over the past several weeks, I have
been working to simplify and focus the project so that all the time we can
invest pays significant rewards for developers and businesses. We'll continue
to streamline and accelerate delivering value to the people investing their
time to use Rubinius.&lt;/p&gt;

&lt;p&gt;Rubinius has a broad and ambitious vision. Since Evan Phoenix created it,
Rubinius has been pushing the envelope. It was one of the first projects in the
Ruby community to use git. One of the first big projects on GitHub. One of the
first projects to use LLVM outside of the LLVM ecosystem. There have always
been skeptics voicing their opinions about Rubinius using Ruby, building
RubySpec, building our own virtual machine and garbage collector, removing the
global interpreter lock, using gems, about almost every aspect of the project.&lt;/p&gt;

&lt;p&gt;Despite this, Rubinius keeps moving forward. People are experiencing the
tremendous value of running concurrent applications on modern hardware,
saturating the CPU cores instead of blowing out the memory. It's trivial to
migrate from MRI to Rubinius, continuing to use familiar platform tools and
running C-extensions. The terrific response to the 2.0 announcement has been
ample validation of our vision for Rubinius. We're just getting started.&lt;/p&gt;

&lt;p&gt;Visit us in the #rubinius channel on Freenode and check out ways you can
&lt;a href=&quot;http://rubini.us/doc/en/contributing/&quot;&gt;contribute&lt;/a&gt; to the project. The
simplest, and always the most fun, way to contribute is to use Rubinius to do
something you find interesting.&lt;/p&gt;

&lt;p&gt;The future is, by definition, undefined. Let's define it.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Rubinius 2.0 Released</title>
    <id>http://rubini.us/2013/10/04/rubinius-2-0-released/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2013/10/04/rubinius-2-0-released/" />
    <updated>2013-10-04T00:00:00-05:00</updated>
    <author>
      <name>Brian Shirai</name>
    </author>
    
    <content type="html">&lt;p&gt;We are thrilled to announce the release of Rubinius 2.0. There are many
exciting things to share. We'll review what Rubinius is, look at what you can
expect from this release and future releases, and talk about plans for the
future.&lt;/p&gt;

&lt;h2&gt;Many Thanks!&lt;/h2&gt;

&lt;p&gt;Rubinius 2.0 would not be possible without the tremendous support and
contributions from so many amazing people.&lt;/p&gt;

&lt;p&gt;Thanks Matz for creating Ruby. Thanks David Heinemeier Hansson for creating
Ruby on Rails, which spread Ruby happiness around the world. Thanks Evan
Phoenix for creating Rubinius and inspiring us to think beyond current
limitations.&lt;/p&gt;

&lt;p&gt;Thanks to the hundreds of contributors for their time, efforts, and frustration
while improving Rubinius and RubySpec. There isn't room to list them all, but
their indelible mark on Rubinius lives on in the source code.&lt;/p&gt;

&lt;p&gt;Thanks to the Ruby developers, students, and businesses that all contribute to
making Ruby better. Thanks to Engine Yard for financially supporting Rubinius
development and sponsoring all those rad tshirts and stickers people loved so
much.&lt;/p&gt;

&lt;p&gt;All of these people and organizations, not just Ruby developers, are &lt;em&gt;the Ruby
community&lt;/em&gt;. Rubinius owes you a huge debt of gratitude.&lt;/p&gt;

&lt;h2&gt;The 2.0 Story&lt;/h2&gt;

&lt;p&gt;With the 2.0 release, Rubinius regains a laser focus on supporting the future
of Ruby. Rubinius 2.0 is expected to be compatible with Ruby 2.1.&lt;/p&gt;

&lt;p&gt;While MRI hasn't released 2.1 yet, Rubinius will continue improving
compatibility as more features are finalized. Last RubyConf, Matz urged people
to upgrade as soon as possible to Ruby 2.0. Significant effort has been
dedicated to making the upgrade from 1.9 as simple as possible. Rubinius
supports the effort to move Ruby into the future.&lt;/p&gt;

&lt;p&gt;Rubinius started life with the goal of bringing modern technology to Ruby's
implementation, giving developers more power, and businesses who rely on Ruby a
faster, more stable and more efficient platform on which to build products and
services.&lt;/p&gt;

&lt;p&gt;Over time, we've tried to support multiple Ruby language versions, many
different projects, old and new code, code that abuses every corner of MRI's
&lt;em&gt;ad hoc&lt;/em&gt; semantics, and every random, undocumented MRI C function with the
Rubinius C-API compatibility layer. Unfortunately, this is unsustainable and
not in the best interests of Ruby or Rubinius.&lt;/p&gt;

&lt;p&gt;Starting with 2.0, Rubinius will concentrate on providing exceptional Ruby
support for building modern concurrent and distributed applications. Not every
legacy Ruby program or quirky Ruby feature will be suitable for Rubinius.
Instead, we'll prioritize the performance and stability of concurrent
applications to make Ruby competitive with Go, Erlang, Clojure, Scala, and
Node.&lt;/p&gt;

&lt;h2&gt;Versions and Releases&lt;/h2&gt;

&lt;p&gt;Starting with Rubinius 2.0, we're changing the way releases are done.&lt;/p&gt;

&lt;p&gt;Every week or so, we'll release a version of Rubinius. We are not following a
pre-determined release schedule. We will continue to keep the master branch
extremely stable, as we have done for years. If there are only bug fixes on
master since the last &lt;em&gt;X.Y.Z&lt;/em&gt; release, the new version will be &lt;em&gt;X.Y.Z+1&lt;/em&gt;. If
there are other changes, the new version will be &lt;em&gt;X.Y+1.0&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;We're moving to this release process to get updates into your hands as quickly
as possible. No matter how much work we do, there is always more. A release
never seems &lt;em&gt;ready&lt;/em&gt;. Releases are painful to get right. So we are following the
advice, &quot;If something is painful, push it to the front and work to reduce the
pain.&quot; There will be bugs with our Ruby 2.1 compatibility. If something is
broken for you, please file an issue. Hopefully it will be fixed and released
within days.&lt;/p&gt;

&lt;p&gt;The goal is to &lt;a href=&quot;http://semver.org&quot;&gt;semantically version&lt;/a&gt; the Rubinius core
starting with version 3.0. During the 2.x to 3.0 transition, we'll be very
careful about introducing breaking changes, but we'll do so when the benefits
outweigh the risks. Obviously, the more we know about how Rubinius is being
used, the better we can evaluate these decisions.&lt;/p&gt;

&lt;p&gt;We've added a subdomain &lt;a href=&quot;http://releases.rubini.us&quot;&gt;http://releases.rubini.us&lt;/a&gt;
for hosting release tarballs. We expect that over the next few days the many
Ruby installers and switchers will be updated to install Rubinius.&lt;/p&gt;

&lt;p&gt;Below, in the section on future plans, I'll explain what we hope to accomplish
with these ambitious release plans.&lt;/p&gt;

&lt;h2&gt;Rubinius Parts&lt;/h2&gt;

&lt;p&gt;Many people have heard that Rubinius is an implementation of the Ruby
programming language. There's a lot wrapped up in that simple description.
Let's review the major pieces of technology in Rubinius today. Later, we will
look at plans to improve these in the future.&lt;/p&gt;

&lt;p&gt;The Rubinius architecture is fairly standard for a modern language runtime.&lt;/p&gt;

&lt;p&gt;The bytecode virtual machine (VM) runs the bytecode produced by the Ruby
compiler. A notable feature is that every Ruby method essentially gets its own
interpreter. This enables powerful features like the full-speed built-in
debugger. Only the specific Ruby method with debugger breakpoints runs the
&quot;debug&quot; interpreter while the rest of the methods run at normal speed.&lt;/p&gt;

&lt;p&gt;The generational garbage collector (GC) has a very fast young generation
collector, usually pausing for less than 15 ms to complete a collection.
Applications running on Rubinius typically see shorter GC pauses times and many
fewer noticeable GC pauses because the entire heap needs to be collected far
less often. Rubinius also has a partially concurrent mark phase for the mature
generation which further reduces the GC pause times when a full collection is
required.&lt;/p&gt;

&lt;p&gt;Rubinius implements native operating system threads for concurrency and has no
global interpreter lock (GIL). Ruby code can run in parallel on multi-core or
multi-CPU hardware.&lt;/p&gt;

&lt;p&gt;The Rubinius just-in-time compiler (JIT) turns Ruby bytecode into machine code.
The JIT thread is mostly independent of the Ruby threads so the JIT operation
doesn't impact the running code's performance. The JIT framework tracks which
methods are often used and what types of objects are seen. Using this runtime
data, the JIT is able to combine application methods and core library methods,
generating highly optimized machine code that runs several times faster than
the bytecode interpreter.&lt;/p&gt;

&lt;p&gt;The Rubinius core libraries (e.g. Array, Hash, Range, etc.), as well as
Rubinius tools like the bytecode compiler, are written in Ruby. The Rubinius
systems treat them just like Ruby application code (e.g. the JIT combining core
library methods and application methods to best optimize running code). This
consistency also improves understanding of the entire Rubinius system. Ruby
developers can contribute to significant parts of Rubinius simply by writing
Ruby code.&lt;/p&gt;

&lt;h2&gt;Plans, Meet Future&lt;/h2&gt;

&lt;p&gt;For Rubinius to have a place in future application development, it must serve
the needs of those applications.&lt;/p&gt;

&lt;p&gt;The world is rapidly changing and the rate of change is accelerating. Building
software today is different than it was just five years ago. Continuous
delivery and A/B testing are becoming commonplace. Businesses must experiment
to discover how to compete in changing conditions. Driving down the cost of
experimenting is essential.&lt;/p&gt;

&lt;p&gt;More now than ever, time is money. The time scale to deliver features must be
hours or days, not weeks or months. To meet the required velocity, building
concurrent and distributed applications in a heterogenous environment is no
longer optional, it is essential.&lt;/p&gt;

&lt;p&gt;Ruby is more suited than many languages to rapidly deliver features, reducing
the cost to experiment and the time needed to begin engaging customers.
Unfortunately, Ruby development has not kept pace with the software as a
service revolution.&lt;/p&gt;

&lt;p&gt;Ruby became popular because Ruby on Rails accelerated the delivery of value by
an order of magnitude. This influence is rapidly declining. Efficiencies that
Rails introduced, things like &lt;em&gt;convention over configuration&lt;/em&gt; and full-stack
integration, also encouraged monolithic application architectures. Applications
built this way are difficult to change and difficult to scale, which means that
under changing conditions, their costs tend to quickly outweigh any value they
deliver. Businesses are rapidly learning this lesson.&lt;/p&gt;

&lt;h2&gt;Future, Meet Plans&lt;/h2&gt;

&lt;p&gt;Roadmaps are notoriously painful because, oddly enough, predicting the future
continues to be an inexact science. Given the future that Rubinius wants to
support&amp;mdash;concurrent and distributed applications&amp;mdash;the following are
specific areas we plan to improve in the coming weeks.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Rubinius has no global interpreter lock, but we can significantly improve
concurrency coordination in the system. During some phases of garbage
collection, some operations of the JIT, and during fork/exec, we have to stop
all the threads. We intend to improve this significantly so that less
coordination is required.&lt;/li&gt;
&lt;li&gt;In place of the GIL, Rubinius uses finer-grained locks internally in various
places. These can be reduced further, improving multi-core efficiency, by using
modern lock-free concurrent data structures.&lt;/li&gt;
&lt;li&gt;While the garbage collector has reasonably low pauses, we can improve this
by making the GC more concurrent and parallel.&lt;/li&gt;
&lt;li&gt;The JIT compiler already often improves Ruby code performance by 2-4x over
executing bytecode. We can do even better. We will improve communicating Ruby
semantics to the JIT to avoid unnecessarily allocating objects and doing
unnecessary bookkeeping that slows performance. We will expose more of the JIT
framework to Ruby to enable rapidly coding and testing new ideas for optimizing
Ruby.&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;Gems as Components&lt;/h2&gt;

&lt;p&gt;The ability to compose independent components is one of the best means to
manage high complexity. In Ruby, the natural way to package, distribute, and
compose components is gems.&lt;/p&gt;

&lt;p&gt;Rubinius wants to bring the advantages of continuous delivery and the
&quot;evergreen browser&quot; idea to Ruby developers. The Rubinius approach to this is
to fully leverage gems.&lt;/p&gt;

&lt;p&gt;Rubinius itself has been dramatically simplified. Major components, like the
bytecode compiler, Ruby parser, debugger, etc. have been moved to gems. These
components can be updated easily and quickly without requiring a Rubinius
release. These components participate in the Ruby ecosystem, for example
&lt;a href=&quot;http://bundler.io&quot;&gt;Bundler&lt;/a&gt; or &lt;a href=&quot;https://github.com/cyx/dep&quot;&gt;dep&lt;/a&gt;, like all the
gems that Ruby developers are familiar with.&lt;/p&gt;

&lt;p&gt;In Rubinius 2.0, the &lt;a href=&quot;http://rubysl.github.io&quot;&gt;Ruby standard library&lt;/a&gt; has also
been converted to gems. The Ruby standard library is some of the oldest Ruby
code that exists. Due to being bundled with MRI all these years, it was far
more difficult to change than a library or gem. Every change required MRI to
accept it, and any changes required waiting for a new release of MRI, something
which did not happen frequently.&lt;/p&gt;

&lt;p&gt;It's not surprising that many people simply went around these obstacles and
made alternate libraries. Instead of being the pinnacle of excellent Ruby
design and idioms, parts of the standard library bit-rotted and retained
anachronisms like embedded tests at the end of files. Further, many of the
critical libraries were written as C extensions, making them unusable by JRuby,
Topaz, IronRuby, Opal, and early MagLev (which now has some C-API support).&lt;/p&gt;

&lt;p&gt;In Rubinius 2.0, the components and standard library are &lt;em&gt;just gems&lt;/em&gt;. There is
nothing special about them. They are installed as gems. They participate in gem
sets and Bundler workflow as gems. There are some challenges required to
bootstrap the gems, but that requires an internal Rubinius command, not changes
to the RubyGems infrastructure.&lt;/p&gt;

&lt;p&gt;Providing the standard library as gems opens the opportunity to rebuild it &lt;em&gt;in
Ruby&lt;/em&gt; and improve the code rapidly so that multiple implementations can share
it. However, we are also not bound to using any of these libraries. Since they
are just gems, they can be put in a Gemfile, &lt;em&gt;or not&lt;/em&gt;, if there are better
libraries available. There's no point spending time &quot;improving&quot; things that no
one wants. Supporting newer libraries with better code and APIs may be much
more beneficial. This is now an option.&lt;/p&gt;

&lt;p&gt;We'll be monitoring what people do and where pain points are. Building on all
the gem infrastructure, we open up a world of possibilities for Ruby
developers.&lt;/p&gt;

&lt;h2&gt;Rubinius Inspirations&lt;/h2&gt;

&lt;p&gt;As 2.0 is a big milestone and transition, it's interesting to reflect on some
significant Rubinius contributions to the Ruby community.&lt;/p&gt;

&lt;p&gt;Rubinius has inspired a number of projects that have benefited Ruby far beyond
Rubinius. The best known of these is &lt;a href=&quot;http://rubyspec.org&quot;&gt;&lt;strong&gt;RubySpec&lt;/strong&gt;&lt;/a&gt;, which
is used by every significant Ruby implementation, including promising new ones
pushing the limits, like &lt;a href=&quot;http://www.topazruby.com&quot;&gt;Topaz&lt;/a&gt; and
&lt;a href=&quot;http://opalrb.org&quot;&gt;Opal&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Rubinius also created the initial &lt;strong&gt;FFI&lt;/strong&gt; spec that opened the world of native
libraries to Ruby with a simple API across implementations and without needing
to write C-extenions.&lt;/p&gt;

&lt;p&gt;Evan created &lt;a href=&quot;http://puma.io&quot;&gt;&lt;strong&gt;Puma&lt;/strong&gt;&lt;/a&gt; to meet the need for a fast web server
that would promote the Rubinius parallel thread support. Puma also works well
on MRI and JRuby. It provides Ruby applications excellent performance and
multi-core scaling, especially when there's no global interpreter lock.&lt;/p&gt;

&lt;p&gt;Rubinius as a language platform has inspired many
&lt;a href=&quot;http://rubini.us/projects&quot;&gt;&lt;strong&gt;projects&lt;/strong&gt;&lt;/a&gt; and encouraged people who may have
thought language design was beyond their skills to experiment and discover the
tremendous joy in creating &lt;a href=&quot;https://github.com/queenfrankie/lani&quot;&gt;&lt;strong&gt;their own programming
language&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It is a joy that Rubinius has been a part of these efforts and we will continue
improving developer experience in these areas.&lt;/p&gt;

&lt;h2&gt;Ready, Set, Ruby!&lt;/h2&gt;

&lt;p&gt;Concurrent and distributed applications aren't the future anymore, they are the
present. They are vital to business success. The many talented developers that
are passing over Ruby for Erlang, Go, Clojure and Node are draining Ruby of
talent and vitality.&lt;/p&gt;

&lt;p&gt;Ruby is an excellent language. Rubinius is dedicated to providing Ruby
developers with excellent tools and technology competitive with these other
languages. Developers who are happy writing Ruby shouldn't be forced to leave
it because of technical limitations.&lt;/p&gt;

&lt;p&gt;If you are one of these developers, let's build the future.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Ready, Set, ...</title>
    <id>http://rubini.us/2013/09/22/ready-set/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2013/09/22/ready-set/" />
    <updated>2013-09-22T00:00:00-05:00</updated>
    <author>
      <name>Brian Shirai</name>
    </author>
    
    <content type="html">&lt;p&gt;&lt;strong&gt; ED: Updated the section on How To Build and added a section on gems and
Rubinius.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;There are some big changes coming in Rubinius. A full post about this should
arrive later in the week, but for people who are tracking master HEAD on the
&lt;a href=&quot;https://github.com/rubinius/rubinius&quot;&gt;GitHub repository&lt;/a&gt;, here are a few
essential pieces of information.&lt;/p&gt;

&lt;h2&gt;What's Changed?&lt;/h2&gt;

&lt;p&gt;I've just merged a work-in-progress branch into master. The master branch now
supports Ruby language version 2.1 only. It also moves Rubinius components,
such as the parser, compiler, debugger, as well as the Ruby standard library,
to gems. The changes lay the foundation for numerous planned features to
improve performance and concurrency support.&lt;/p&gt;

&lt;p&gt;The syntax support for 2.1 is not yet complete but should be merged in a few
days.  Applications using Ruby 1.9.3 are expected to run. The standard library
gems are installed by default, so there should not be a noticable difference
in how programs using the standard library run.&lt;/p&gt;

&lt;h2&gt;How To Build&lt;/h2&gt;

&lt;p&gt;To build Rubinius, MRI 2.0 or Rubinius master are required. Other versions may
work, but are not supported. Bundler is also required.&lt;/p&gt;

&lt;p&gt;The easiest way to get MRI 2.0 if it's not already installed on your system is
probably &lt;a href=&quot;https://github.com/postmodern/ruby-install#readme&quot;&gt;ruby-install&lt;/a&gt;.
However, use whatever is easiest for you to install MRI 2.0. Rubinius also
highly recommends using &lt;a href=&quot;https://github.com/postmodern/chruby&quot;&gt;chruby&lt;/a&gt; as a
Ruby switcher.&lt;/p&gt;

&lt;p&gt;To clone and build, follow these steps:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;git clone --depth 1 https://github.com/rubinius/rubinius&lt;/li&gt;
&lt;li&gt;cd rubinius&lt;/li&gt;
&lt;li&gt;bundle&lt;/li&gt;
&lt;li&gt;./configure --prefix=/path/to/install&lt;/li&gt;
&lt;li&gt;rake&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;The main difference is that bundle is used to install build requirements.&lt;/p&gt;

&lt;p&gt;After building, add &lt;code&gt;path/to/install/bin:/path/to/install/gems/bin&lt;/code&gt; to PATH to
run Rubinius. Alternatively, use a Ruby switcher like
&lt;a href=&quot;https://github.com/postmodern/chruby&quot;&gt;chruby&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;What Are Gems?&lt;/h2&gt;

&lt;p&gt;As noted above, the Ruby standard library in Rubinius, and other Rubinius
components like the code build tools and developer tools, are provided as
gems.  These are regular gems. There is nothing special about them. They are
installed as gems, they are bundled as gems, they are updated with &lt;code&gt;gem
update&lt;/code&gt;, they are simply gems.&lt;/p&gt;

&lt;p&gt;You even have the option at configure time to not install them (except for a
few that are required to run (e.g. IRB), but we plan to make this optional as
well). See &lt;code&gt;configure --help&lt;/code&gt; for the &lt;code&gt;--with[out]-stdlib&lt;/code&gt; configure option.&lt;/p&gt;

&lt;p&gt;Since they are gems, other Ruby ecosystem components, like Bundler, need to
know about them. When using Bundler, for example, add &lt;code&gt;gem &quot;rubysl&quot;, &quot;~&amp;gt; 2.0&quot;&lt;/code&gt;
to your Gemfile. For other dependency management, what is needed depends on
how intrusively it invades the Ruby require process.  With plain RubyGems,
simply install the gems and requires will work as expected.&lt;/p&gt;

&lt;p&gt;There are several meta-gems provided (e.g. rubysl, rubysl-rake,
rubysl-bundler) that can be used to install all the standard library gems that
those tools depend on. To install (or update) the entire standard library, run
&lt;code&gt;gem install rubysl&lt;/code&gt;.&lt;/p&gt;

&lt;h2&gt;Where Are 1.8 &amp;amp; 1.9?&lt;/h2&gt;

&lt;p&gt;There are two branches under Rubinius for
&lt;a href=&quot;https://github.com/rubinius/rubinius/tree/1.8.7&quot;&gt;1.8.7&lt;/a&gt; and
&lt;a href=&quot;https://github.com/rubinius/rubinius/tree/1.9.3&quot;&gt;1.9.3&lt;/a&gt;. The default language
mode when building from the branches matches the branch name. These branches
are provided to ease transitions. No active development will occurr on the
branches. If you would like to volunteer to maintain one of the branches,
please let us know.&lt;/p&gt;

&lt;h2&gt;Issues&lt;/h2&gt;

&lt;p&gt;Please open an &lt;a href=&quot;https://github.com/rubinius/rubinius/issues&quot;&gt;issue&lt;/a&gt;
if you have any trouble building or running the master branch.&lt;/p&gt;

&lt;p&gt;More details coming soon. Happy Rubying!&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Concurrent garbage collection</title>
    <id>http://rubini.us/2013/06/22/concurrent-garbage-collection/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2013/06/22/concurrent-garbage-collection/" />
    <updated>2013-06-22T00:00:00-05:00</updated>
    <author>
      <name>Dirkjan Bussink</name>
    </author>
    
    <content type="html">&lt;p&gt;Just a few days ago my work on making the Rubinius garbage collector more
concurrent has landed in Rubinius master. In this post I'll describe how
this work was done and what the ideas behind it and pitfalls encountered
are. Hopefully after reading this post, you'll better understand what
concurrent garbage collection means for your Ruby programs and how they
operate. Note that I have explicitly chosen to keep things like benchmark
and performance numbers out of this post - it is long enough as is.&lt;/p&gt;

&lt;h3&gt;In the beginning there were long pauses&lt;/h3&gt;

&lt;p&gt;Garbage Collection pauses: anyone with a somewhat complex app usually
knows about them. They often result in wildly varying performance of
your web requests and cause performance issues in unexpected
situations. There has been a lot of effort put towards working around
these issues, such as out of band garbage collection done with servers
such as Unicorn and Passenger. Honestly, I think these techniques are
very useful but in essence still workarounds because of a deeper
problem in MRI.&lt;/p&gt;

&lt;p&gt;With this work on concurrent garbage collection, long pauses are a
thing of the past in Rubinius. You can run a single process application
server and see stable and fast performance in highly concurrent scenarios.&lt;/p&gt;

&lt;p&gt;So for this post I'll first introduce some fundamental concepts that we
needed to make explicit in Rubinius to support concurrent garbage
collection. After that I'll discuss some of the issues encountered when
stress testing and putting Rubinius under load with applications such as
Rails and Sidekiq. Often there will be a reference to a commit, this is
because commits won't change, but code can. This makes sure this is still
correct and relevant even when things are changing in the future.&lt;/p&gt;

&lt;h3&gt;The tri-color invariant&lt;/h3&gt;

&lt;p&gt;For people having some knowledge about garbage collection theory, the
term tri-color invariant probably sounds familiar. It is a term that
describes a property of the system that is important in being able to
garbage collect properly without for example cleaning up used data.&lt;/p&gt;

&lt;p&gt;The tri-color invariant defines three different states for an object:
white, grey and black. Each of these states describes the state of an
object during a garbage collection phase.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;White objects&lt;/strong&gt; are objects that the garbage collector hasn't seen yet
and doesn't know about yet. It might be found in the future, or it might
not if it's actually garbage and not a reachable object.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Grey objects&lt;/strong&gt; are objects that the garbage
collector has seen, but hasn't completely handled yet. By handling I
mean that this object has not been completely scanned for references to
other objects. This means for example that we haven't visited the class
or instance variables table in Rubinius.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Black objects&lt;/strong&gt; have been seen by the garbage collector
and also has been scanned. This means that this object is handled and
doesn't need to be revisited again during the current phase.&lt;/p&gt;

&lt;p&gt;Garbage collection works in different phases. The first phase is to
start and mark objects known as roots. Roots are objects that we define
as always reachable and who should never be cleaned up. One example
of these in Rubinius are the built-in classes. We never want to garbage collect
Module, Class or Object. Another group of root objects are the objects
currently on the stack when we garbage collect. These might be used still
after the garbage collection finishes and the application continues to run.&lt;/p&gt;

&lt;p&gt;When we start the garbage collection cycle, we make the roots grey. This
is done in Rubinius by marking them and adding them to a list of objects
that are going to be scanned in the future. This allows us to do garbage
collection without having to use recursion here, which could lead to very
deep call stacks and potential stack overflows.&lt;/p&gt;

&lt;p&gt;When we have done this, we start handling the so called mark stack. We
pop off an object and scan it. This makes the object implicitly black,
because it is marked and no longer in the mark stack. It is important to
realize that the invariant colors are not always explicit states, but
sometimes implied by the total system state. They are a tool for
reasoning about garbage collection, not a design for how you must write
an algorithm.&lt;/p&gt;

&lt;p&gt;During the scanning of an object we might encounter new (&quot;white&quot;) objects.
We mark them and add them to the mark stack as well, thus making them grey.
This process of handling the mark stack continues until the entire mark
stack is empty. At that point we know that all the reachable objects are
now black and the remaining objects can be cleaned up.&lt;/p&gt;

&lt;p&gt;From these steps you can see the following invariant:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;&quot;A black object never points to a white object, but always only to grey or other black objects.&quot;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This invariant is important because if it were to be violated, we would clean
up a white object if it would be never marked. But that would mean the
black object would refer to garbage instead of a valid object.&lt;/p&gt;

&lt;h3&gt;Tri-color invariant and concurrency&lt;/h3&gt;

&lt;p&gt;Maintaining the tri-color invariant is important for correctness. If you
look at the reasoning in the previous section, you might already realize
where violation of the invariant might happen in a concurrent scenario.&lt;/p&gt;

&lt;p&gt;The simplest example is the following. When we start to handle the mark
stack, we scan objects and make them implicitly black. Now imagine the
case where our code (that still runs during GC) writes an unseen white
object into that already scanned black object. In this case we can't
guarantee the tri-color invariant because our application might change
things behind our back without the garbage collector knowing about it.&lt;/p&gt;

&lt;p&gt;So the question is, what would be a solution for this problem? Well, the
obvious thing would be to make sure we run some additional checks when
we encounter the scenario of a white object being writing into a black
object. This means, however, that we have to make sure we can catch all
these cases where this happens. What if somewhere in the virtual machine
we would assign a variable and not run this code? It would mean breaking
the invariant and that leads to memory corruption down the road.&lt;/p&gt;

&lt;p&gt;This situation represents a triumph in the history of Rubinius engineering -
because the VM already had a Generational GC and no global interpreter
lock, the work that went toward making the GC concurrent was much simpler.
Let's try to understand why.&lt;/p&gt;

&lt;h3&gt;The write barrier&lt;/h3&gt;

&lt;p&gt;In generational collection, we have a problem that is somewhat similar
to the tri-color invariant problem here under concurrent garbage
collection. Generational garbage collection stems from the &quot;weak generational
hypothesis&quot; which states that &quot;objects tend to die young.&quot; One
obvious example of this can be found in Rails. The objects loaded in
your Rails app often consist of two classes of objects.&lt;/p&gt;

&lt;p&gt;The first class of objects are all the objects that define your app. For
example the class definitions of your controllers and models, but also
templates for your views. These objects stick around for the entire
lifetime of your application. The second class of objects are the ones
allocated when you handle a request. They only live for the lifetime
of the request, so if you would only garbage collect those objects after
a number of requests, you would already prevent any memory growth.&lt;/p&gt;

&lt;p&gt;This is a very simple example of the generational hypothesis and why
generational garbage collection works well on workloads like Rails. But
I said that this suffers from a similar problem as the tri-color
invariant violation, so what is that problem?&lt;/p&gt;

&lt;p&gt;The problem occurs if you cross the barrier between young and old
generations. For example you store a new object into a long existing
array. That array is part of the mature generation. What you don't want
to happen is that when we clean up the young generation, we miss this.
If we would, the array would suddenly contain garbage and no longer a
valid object. This means that also for this problem we need to run an
additional check when writing an object into another object.&lt;/p&gt;

&lt;p&gt;The code running these checks is called a write barrier, because it's a
piece of code that is being run on each write of object into another
object. What exactly this code is depends on the use
case. We have already described two of them now, one for generational
and one for concurrent garbage collection.&lt;/p&gt;

&lt;h3&gt;The remember set&lt;/h3&gt;

&lt;p&gt;So we've just discussed the write barrier. It also stated that we
already have a write barrier for generational collection. For some of
the issues mentioned later on, the generational concerns are also of
significance, so it's useful to also explain the concept of the remember
set.&lt;/p&gt;

&lt;p&gt;The remember set is a set of objects that is used to scan for young
objects during a generational collection. This is needed for the cases
where we store a reference to a young object into a mature object. What
we do is store the mature object in the remember set, so we can scan it
when we do a young collection. This makes sure we follow all the paths
which through a young object is reachable.&lt;/p&gt;

&lt;h3&gt;Changing the write barrier for concurrent GC&lt;/h3&gt;

&lt;p&gt;So we need to be able to run some code when we are writing a white
object into a black one during generational garbage collection. Because
we already have a write barrier, we should have a single place where we
can change this.&lt;/p&gt;

&lt;p&gt;Well, that was not entirely true. As part of implementing the concurrent
garbage collection solution, I also cleaned up some of the internals to
unify for example our usage of write barriers. It wasn't a terribly
daunting task, since the logic was already there, just that we had the
logic in more than one place. If you want to take a look at what this
work was, I'd suggest taking a look at the diff here:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rubinius/rubinius/commit/c426e7bdfea54a742fc598d104a5fd756db27a6a&quot; title=&quot;Unify write barrier access&quot;&gt;Unify write barrier access&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If you read through the commit, you can see it actually removes more
code than it adds, because it cleans up and unifies the usage of the
write barrier.&lt;/p&gt;

&lt;p&gt;So this brings us to the next point of how to change the write barrier.
What we need to do is to make sure we guard the case where we store a
white object into a black object. If we detect this scenario, there are
basically two possible strategies. The first one is the make the white
object grey by marking it. This means we will scan it in the future. The
other option is to make the black object grey again, so we scan that
again in the future.&lt;/p&gt;

&lt;p&gt;The first solution has the advantage of moving the collection forward,
not backward like the second solution. It does however have the downside
that it could keep objects alive longer than the second solution would.
In the implementation for Rubinius we've chosen the first option,
mainly because it proved to be the simplest to implement and it moves
the so-called wavefront forward.&lt;/p&gt;

&lt;p&gt;The other thing we need for this check is to know whether an object is white,
grey or black. As you might remember, I've said before that these states
might not be explicitly modeled. This was actually the case in
Rubinius. There was a way to determine that an object was black, namely
when it was marked but not in the mark stack anymore. The first check is
easy and cheap, but the second check isn't. We would have to scan the
entire mark stack for an object if we want to write another one into it.
This would quickly become really expensive and isn't a good solution.&lt;/p&gt;

&lt;h3&gt;Introducing a new garbage collection state&lt;/h3&gt;

&lt;p&gt;The only way to really tackle this problem is to introduce a new state
for an object, so we can easily see that it's already scanned, not only
just marked.&lt;/p&gt;

&lt;p&gt;For this I also have to take a sidestep and explain another concept,
namely the rotating mark concept. If you look at how to track the state
during the mark phase, there are a few solutions. The easiest one is to
have a single bit to identify whether we've marked an object or not.
This comes with a downside though, that we have to make sure we set all
the marks back to 0 before we start a garbage collection, or at the end
of a garbage collection so it's 0 for the next cycle.&lt;/p&gt;

&lt;p&gt;To prevent this overhead, there is a concept called a rotating mark.
It's actually very simple, instead of having a mark of 0 or 1, we have
0, 1 and 2. When an object is new, it still has a mark of 0. The first
time when we garbage collect, we use 1 as the mark. This means we can
clean up all the objects afterwards which don't have mark 1.&lt;/p&gt;

&lt;p&gt;The second time we swap the mark to 2 and do the same thing. We can
remove anything with a mark that is not 2 after the collection cycle.
This is a concept that the garbage collection in Rubinius already used
before these changes. So what we did was extend the mark bits to also
include the scanned state. Rubinius uses the object header to store
this information inside the object and we had a few more bits of room
to store additional information.&lt;/p&gt;

&lt;p&gt;We could have solved this basically in two ways, one would be to just
use a single bit as the scanned state. This would work fine, but it
would make updating the header with this bit more expensive in certain
concurrent scenarios, where we would end up doing a compare and swap
operation twice instead of once.&lt;/p&gt;

&lt;p&gt;Therefore we opted for merging it with the mark bits. This means that
instead of 2 bits to store 0, 1 or 2, we now use 3 bits to store 0, 2,
3, 4 or 5. Why is 1 not used you might ask? Well, that is a side effect
of the combination of a rotating mark and the scanned state.&lt;/p&gt;

&lt;p&gt;The scanned state is actually represented in the last bit. So a value of
1 would mean the object is scanned, but not marked. Since we always
first mark an object before scanning, this scenario can't happen. The
values 2 and 4 mean the object is only marked, the values 3 and 5 mean
the object is marked and scanned. These values also make the operations
for checking if a mark is set and setting the scan state simple.&lt;/p&gt;

&lt;p&gt;You can find the code that introduces this new state in the following
commit:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rubinius/rubinius/commit/d1d99d6048a01f1687080f98baa904d4562ed920&quot; title=&quot;Introduce explicit scanned state for mature GC&quot;&gt;Introduce explicit scanned state for mature GC&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;A new version of the write barrier&lt;/h3&gt;

&lt;p&gt;So with this new addition, we actually have the tools at hand to change
the write barrier so we can handle this new case for the concurrent
garbage collection. So besides checking the generations of the objects,
we now also have to check the newly introduced scanned state, which
represents the black state in the tri-color invariant. If the object we
write into is already black and the object to be written is white, we
store this object in a separate set.&lt;/p&gt;

&lt;p&gt;This set is then in the finalization phase of the concurrent garbage
collector used. How this works exactly will be explained later, for now
it's important to remember that objects in this set will be marked in
the future.&lt;/p&gt;

&lt;p&gt;The new version of the write barrier can be found here in this commit:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rubinius/rubinius/commit/bcecb3103d450502bd43a3411461381f5452a7e0&quot; title=&quot;Update write barrier with checking for scanned objects&quot;&gt;Update write barrier with checking for scanned objects&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As you see, it also incorporates more changes, mainly the addition of
the before mentioned set and changes to the JIT. The changes to the JIT
are necessary because the JIT basically emits the assembly code for the
write barrier directly, so it also needs to emit the new version of the
code.&lt;/p&gt;

&lt;p&gt;There is one thing here that might strike some as surprising. That is
the fact that we actually set the scanned state before scanning the
object. This is not a bug, but deliberate, since otherwise there is a
race condition possible. The race condition would be that a scan of on
object is in progress while another thread runs the write barrier for
that same object. In that case it could see the object as not scanned,
and not store the new reference. The other thread would then mark the
object as scanned, but it would still have a white object stored. This
would violate the tri-color invariant and cause corruption.&lt;/p&gt;

&lt;p&gt;By setting the scanned state as the first operation, the only risk is
perhaps adding an element unnecessary due to a race condition, but this
isn't problematic but just a minor increment in the amount of work.
Since this only happens with this race condition, this case is so small
it doesn't cause any performance issues.&lt;/p&gt;

&lt;h3&gt;The actual concurrent garbage collection&lt;/h3&gt;

&lt;p&gt;So with these pieces put into place, I was kind of surprised. It only
had taken very little work to add these new concepts, a testament I
think to the design that Evan and Brian originally started. Most of you
probably know the feeling where you start to implement a seemingly
daunting feature, but after starting it everything falls into place so
easily you feel something must be wrong. Of course at this point it did
take me longer to finish the work, but luckily not because of
fundamental problems with the approach, but just with bugs for certain
edge cases.&lt;/p&gt;

&lt;p&gt;So with this initial surprise out of the way, let's see how the basic
algorithm works. The first thing that is important to realize, is that
this is a mostly concurrent garbage collection, so it's not 100%
concurrent. There are still stop the world pauses, but they are much
smaller than with a complete stop the world collection.&lt;/p&gt;

&lt;p&gt;These stop the world pauses are needed to get a consistent view of the
roots to start collection from and to finish it all up to get another
consistent snapshot of the system. So what we do is trade one big stop
the world pause for two much smaller ones.&lt;/p&gt;

&lt;p&gt;During the first stop the world, we do the same thing we did before to
setup the initial state to start collection with. After this is done, we
signal all the threads that they can continue to do their work, while a
separate thread will start the mark phase. This mark phase will happen
concurrently with the other threads running. When the mark thread has
marked everything in the mark stack, we request the second stop the
world phase. In this second phase we rescan all the roots, because they
might have changed. This means also rescanning the thread state so we
can see what is on the stack at that point.&lt;/p&gt;

&lt;p&gt;After we do this, we also schedule the special set that the write
barrier has tracked during execution. We add that as well to the mark
stack. We then scan the remaining mark stack during this stop the world
phase. This is in general a much smaller stack, because we already
scanned the majority of the system.&lt;/p&gt;

&lt;p&gt;After we've finished scanning the mark stack, we do the same
finalization as we did before in the stop the world collector. We have
to handle things like finalizers, C-API handles etc. and also sweep up
the garbage. If this final phase has finished, we can continue running
everything and garbage collection for this iteration is done.&lt;/p&gt;

&lt;p&gt;The commit introducing this new thread can be found in:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rubinius/rubinius/commit/22c8c9c72e35be71d4258f00e57d8e9bb1f91a2f&quot; title=&quot;Introducing concurrent mature mark phase&quot;&gt;Introducing concurrent mature mark phase&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Most of the changes are for updating the gathering of statistics. We of
course want to know how much time is spent in the stop the world pauses
and the concurrent mark phase, so we can easily see the benefits of this
strategy. Another large amount of the code is actually dedicated to
supporting another feature, which is described in the next section.&lt;/p&gt;

&lt;h3&gt;Running young collections while concurrently marking&lt;/h3&gt;

&lt;p&gt;One thing that is of concern when doing a concurrent garbage
collection of the whole program is what happens to the young
generation. As explained earlier, Rubinius has a generational garbage
collector, so we run different styles of collection at different times.
Only when a young collection can't satisfy memory release, or we have
allocated a lot in mature space, we trigger a full concurrent
collection.&lt;/p&gt;

&lt;p&gt;The easiest way to prevent this issue is of course preventing a young
collection from happening while we're concurrently marking. This however,
introduces a significant problem. The problem is that when this happens,
any allocation that would normally create a young object can't succeed.
This means those objects would be allocated as mature objects,
increasing the memory pressure for the total system.&lt;/p&gt;

&lt;p&gt;In a system that for example runs Rails with reasonably complex pages,
it's not that strange a situation that we would want to run multiple
young collections during the runtime of the concurrent mark phase. If we
don't solve this problem, this would mean megabytes more of mature
objects being allocated.&lt;/p&gt;

&lt;p&gt;The young collection still happens in a stop the world phase. This stop
is not that problematic, since it only takes a short time to collect the
young space. This is because it only copies over live objects and it's
limited in size. This means that collection times are usually in the
order of a few milliseconds.&lt;/p&gt;

&lt;p&gt;So we can use the fact that we stop the world in this cases to make sure
we update all the structures at that point for the concurrent mark
phase. The biggest thing here is that we need to update the mark stack
and other similar structures, such as the set of weak ref objects and
the finalizers.&lt;/p&gt;

&lt;p&gt;Since the concurrent mark phase marks all objects, it also marks young
objects. It needs to see the copied objects if they are still alive.
This also applies to the set that is tracked by the write barrier.&lt;/p&gt;

&lt;h3&gt;Inflated headers and code resources&lt;/h3&gt;

&lt;p&gt;Another solution to the problem of writing white objects into black ones
is to always make all objects grey if they are allocated during
a concurrent garbage collection cycle. This approach is similar to how
we solved problems with other managed resources that aren't Ruby
objects.&lt;/p&gt;

&lt;p&gt;There are two types of those objects worth mentioning, inflated headers
and code resources. The first one is a place where we store information
if it doesn't fit in a normal object header, or when it requires non
moving memory. This last required applies for example to using an object
as a Mutex, which is possible with Rubinius much like how the JVM also
works. We can't just move memory if an object is locked, so we keep that
information separate.&lt;/p&gt;

&lt;p&gt;The inflated headers also keep a mark. This is done so we can clean them
up after a garbage collection cycle and deallocate space for objects
that are not longer alive. This means we now have two marks which
implies a possible race condition. What if an object is marked by one
thread and concurrently inflated by another? We would need to make sure
we don't lose information in that case about the inflated header mark.&lt;/p&gt;

&lt;p&gt;Since we don't inflate objects often, we choose a very conservative
approach here. What that means is that if an inflated header is
allocated, it always gets the current mark set as it's mark. It means
that the inflated will possibly not be reclaimed during the first
garbage collection if the object is already out of reach. We don't view
this as a problem, since inflated headers often are allocated for
objects that will stick around longer, for example because they are used
as a lock.&lt;/p&gt;

&lt;p&gt;The second case is code resources. Code resources are things like code
compiled into the virtual machine representations of bytecode, or native
code created for jitted functions.&lt;/p&gt;

&lt;p&gt;Here we use the same approach: always allocate them with the
current mark. Code resources are also very likely to stay around, since
often code gets executed more than once. This approach here is also the
simplest for fixing issues related to this problem.&lt;/p&gt;

&lt;p&gt;These changes where made in the following two commits:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rubinius/rubinius/commit/c41e3a66ff476864e5996ca0a536e1644e745c66&quot; title=&quot;We always create a code resource as marked initially&quot;&gt;We always create a code resource as marked initially&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rubinius/rubinius/commit/76039182e837d2e1460e008f2d11515d27e499cc&quot; title=&quot;Initialize inflated header marks with current mark&quot;&gt;Initialize inflated header marks with current mark&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Fibers and how they affect stack scanning&lt;/h3&gt;

&lt;p&gt;Fibers are somewhat special. They have a part that works like a normal
Ruby object, for example where we store the return value of a fiber. The
other parts of a fiber is the actual stack that is executing.&lt;/p&gt;

&lt;p&gt;In the past we tracked these two things separately, but that wasn't
actually needed. The problem is that with concurrent collection, we have
to separate them again. This is needed because we can't concurrently
scan the stack parts of a fiber, since those stacks could be executing
and become invalid at any moment.&lt;/p&gt;

&lt;p&gt;This means we have to separate the handling of the stacks from the
normal object. We can then scan all the stacks in the final collection
phase for all the fibers that are marked and thus reachable at that
point. If we don't do this, applications like Sidekiq that heavily use
Fibers will crash almost instantly on the first garbage collection
cycle.&lt;/p&gt;

&lt;p&gt;This change was made in commit:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rubinius/rubinius/commit/b3579cfd46fb773b563e0f66154187dc32f31909&quot; title=&quot;Return of tracking the fiber data explicitly&quot;&gt;Return of tracking the fiber data explicitly&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;The first more subtle bug&lt;/h3&gt;

&lt;p&gt;The additional of the concurrent mark thread is also where the first
subtle bug was introduced and subsequently fixed. As in the previous
section described, we have to update the mark stack during a young
collection cycle.&lt;/p&gt;

&lt;p&gt;During a young collection cycle, objects can be promoted. This happens
when objects are alive for a certain number of young collections and are
moved to the mature space. During this time, the allocation mechanism
also changes and the object gets allocated in the area where we sweep
after a concurrent mark phase is complete.&lt;/p&gt;

&lt;p&gt;The bug only happened when a young object was promoted that was already
marked in the concurrent mark phase. This means the object header
already had the mark set. The tricky thing here is that the mature
memory space also as a separate mark table. This is part of the
Immix algorithm used.&lt;/p&gt;

&lt;p&gt;What would happen if a marked object was promoted is that the mark was
retained. This means however, that the underlying Immix memory space was
not marked. This means that during the sweep phase the memory was
incorrectly seen as not in use and reclaimed. This leads to memory
corruption because now a piece of memory is used for two different
objects.&lt;/p&gt;

&lt;p&gt;The solution to this problem is actually very simple. The only thing we
have to do is when an object is promoted, is to remove the mark. This
makes sure that when this object is stored into some other object, it
would go through the write barrier and will be scheduled for proper
marking in the future. This will result in the underlying memory to be
also marked and the problem is gone.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rubinius/rubinius/commit/22c8c9c72e35be71d4258f00e57d8e9bb1f91a2f#L14R488&quot; title=&quot;Introducing concurrent mature mark phase&quot;&gt;Introducing concurrent mature mark phase&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Concurrency, forking and deadlock hell&lt;/h3&gt;

&lt;p&gt;One of the most difficult features to get working correctly in a
concurrent virtual machine like Rubinius is forking. I can perfectly
understand the reason for the JVM not supporting this, besides it not
being cross platform. It requires careful orchestration of all the threads
to prevent the child process from ending up in a problematic state.&lt;/p&gt;

&lt;p&gt;Of course, since we added a new thread for concurrent marking, this also
introduced a deadlock that could be triggered by forking easily. This
was evident in a Sidekiq app that relied on forking to spawn subprocesses
with the fork and exec pattern.&lt;/p&gt;

&lt;p&gt;The problem here was that we still had the lock that is used to
safeguard the internals of the marker thread, while also waiting for a
stop the world pause. This stop the world pause would then be triggered
by a &lt;code&gt;fork()&lt;/code&gt;, which then also requests all the auxiliary threads in the
system to pause at a safe point.&lt;/p&gt;

&lt;p&gt;To get to this safe point, the forking thread would try to grab the lock
of the Immix thread, which it couldn't because the thread itself still
had the lock. The fix is similar to how other auxiliary threads such as
the signal thread and finalizer thread work, by releasing their own lock
just before they mark themselves as being dependent on the garbage
collector again.&lt;/p&gt;

&lt;p&gt;This problem was fixed in commit:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rubinius/rubinius/commit/e74d1fa0756e3f52f3535196a8106e3d29e0c34a&quot; title=&quot;Fix deadlock when forking when immix thread is active&quot;&gt;Fix deadlock when forking when immix thread is active&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Finalizers are tricky to get right&lt;/h3&gt;

&lt;p&gt;This last found and fixed bug was the most elusive one. It was really
hard to trigger and only happened rarely, but luckily often enough so
that finding it wasn't completely impossible. As always with these bugs,
reproducing the bug is really 50% of all the work. 49% is finding what
causes it and 1% of the time is actually spent fixing it. Remember
though, that 80% of all statistics are made up on the spot.&lt;/p&gt;

&lt;p&gt;Here again the intricate play between different threads and the timing
dependency of execution caused the issue to only appear rarely. The
easiest way to reproduce it, was to run a Sidekiq test application that
cpuguy83 graciously provided for finding another bug.&lt;/p&gt;

&lt;p&gt;After running at full speed for maybe somewhere in between 5 and 10
minutes it would crash. Such long feedback cycles can be very
frustrating and make digging into it slow. However, the rewarding
feeling and actually providing people with a stable Ruby runtime is
definitely worth the hassle.&lt;/p&gt;

&lt;p&gt;So what was at play here? First of all, it is important to know about
finalizers. Finalizers are functions you can register that run when the
garbage collector determines an object has gone out of scope. Inside
Rubinius we use this for a number of classes, such as for IO to close it
if it hasn't been and for Fiber's to clean up the stack space they might
have allocated.&lt;/p&gt;

&lt;p&gt;This last category of object is actually what triggered the problem in
Rubinius. It looked like a fiber during the finalization had references
to no longer valid young objects. These young objects would for example
be the value that a fiber stores as the return value. So the question is
what was causing these invalid objects? It looked like the fiber was no
longer properly scanned during young collections and didn't see any
updated value.&lt;/p&gt;

&lt;p&gt;That last sentence might seem easy and straightforward, but it took a
few hours to actually consciously realize the implications of it. I
sometimes call it &quot;A-ha driven development.&quot; The point where you just poke
at code, trying to see through it in a concurrent scenario, until the
case where it can go wrong pops into your head. I haven't been able to
really identify the though processes going into it, but it includes a
lot of poking around and pondering.&lt;/p&gt;

&lt;p&gt;Actually often in cases like that I just go and take a walk to ponder
things, or if it's late just go to bed. I've literally had eureka
moments the next morning in the shower, realizing what the problem was.
If anyone has insights or ideas on how to improve this process, I really
welcome them. I'd love to get a better handle on it to see if it can be
made more consistent in some way.&lt;/p&gt;

&lt;p&gt;So let's go back to the original sentence that is much more important
than it seems. It stated that the problem occurred if a mature fiber
object would not have it's young variables updated. This should makes us
remember the concept of the write barrier. As explained we use that to
make sure that if we add a young object to a mature object, we register
that. What happens in that case is that the mature object is stored in a
remember set, that is always scanned during a young collection. This
ensures these values get updated properly.&lt;/p&gt;

&lt;p&gt;So what was happening here? After adding some debug logic (yes, just
lots and lots of printf statements), I could see that the Fiber was no longer in
the remember set. But it should be, since it had young objects
referenced to it!&lt;/p&gt;

&lt;p&gt;So the question is why is it removed from the remember set. Normally if
a young object is collected and stored back into the mature object, the
write barrier gets executed and the object is added to the remember set
that is used in the next cycle. Why doesn't this happen in this case? So
after looking for where we active remove objects from the remember set,
I found this actually happens during finalization. After an object is
finalized, we removed it from the remember set since it couldn't be
referenced anywhere anymore.&lt;/p&gt;

&lt;p&gt;This reasoning was perfectly sound until we introduced concurrent
garbage collection. Because that suddenly introduces a new place that
the object might still be referenced from, namely the current mark
stack! This means that this goes wrong in the following scenario. The
fiber is in the concurrent mark stack, which could happen because for
example it was still active when concurrent collection started. Then the
fiber goes out of scope and during a young collection it is scheduled
for finalization. Because finalization has to keep objects alive, it has
to keep the fiber live. This would then cause the fiber to be promoted
and to be a mature object. The concurrent mark stack would be updated
with the reference to this now mature object. This would also result in
the now mature fiber to be added to the remember set.&lt;/p&gt;

&lt;p&gt;So this sets the stage for the bug, what would happen next is that the
finalizer would run and after it completed, it would removed the mature
fiber from the remember set. Meanwhile, before we actually reach the
fiber in the concurrent mark phase, another young collection runs. This
young collection then moves the object inside the fiber, for example the
return value. Now finally the concurrent mark stack reaches the fiber
and crashes, because it sees an invalid object as the fiber's return value.&lt;/p&gt;

&lt;p&gt;So how do we fix this? Well, the fix is actually simple, we just don't
remove a finalized object from the remember set. This means it still is
scanned during young collections. The downside is that more objects
might end up being promoted than necessary, but that's better than
completely crashing and breaking the guarantees a garbage collector
should give.&lt;/p&gt;

&lt;p&gt;There is room to improve here for the future though, we could check if a
mature collection is in progress and only then not remove the object
from the remember set. Since starting a mature mark phase always
happens in a stop the world phase, this check shouldn't be problematic
due to race conditions.&lt;/p&gt;

&lt;p&gt;You can find the actual fix for this bug in this commit:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rubinius/rubinius/commit/b1c65d7e8d90e5ad3d1f63c8dc2c2f1f3e0508d6&quot; title=&quot;Don't remove finalized objects from remember set&quot;&gt;Don't remove finalized objects from remember set&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Unknown unknowns&lt;/h3&gt;

&lt;p&gt;For now, these are the issues and problems encountered during the
implementation of the concurrent garbage collector. I'm sure there will
be more garbage collection related bugs in the future, although I think
they will often be bugs that also are present for our non-concurrent
collection. Of course there were also issues like just wrong syntax that would cause
C++ compile errors etc, but those are of course not that interesting
to talk about and part of the normal development progress.&lt;/p&gt;

&lt;p&gt;I've stress tested the concurrent collector under different load
patterns, like running a concurrent Rails application and Sidekiq test
applications. Those systems are often pretty good in finding concurrency
bugs and race conditions and since those are stable, I'm pretty
confident that this is ready for more broad usage. This is of course
also why it was merged into master.&lt;/p&gt;

&lt;p&gt;I've tried to highlight the tricky and more complex issues here, so you
hopefully have a better insight into what implementing all this means.&lt;/p&gt;

&lt;h3&gt;Resources&lt;/h3&gt;

&lt;p&gt;If you're interested in more background on the things discussed here,
these are some pointers to more resources. As a general reference work,
there is the Garbage Collection Handbook. So far the best book on
garbage collection I've seen with a lot of clearly explained content.
It provides a really good starting point to learn about garbage collection
and contains a lot of references to papers that can be read for even
digging deeper into the subject matter at hand.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://gchandbook.org&quot;&gt;The Garbage Collection Handbook website&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.amazon.com/gp/product/1420082795&quot;&gt;The Garbage Collection Handbook on Amazon&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The original paper in the Immix garbage collector, which Rubinius uses.
Note that our version of Immix isn't compacting, something that made concurrent
collection possible. In the future this is something we want to revisit
and improve upon.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://users.cecs.anu.edu.au/~steveb/pubs/papers/immix-pldi-2008.pdf&quot;&gt;Immix: A Mark-Region Garbage Collector with Space Efficiency, Fast Collection, and Mutator Performance&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;For finding more resources on garbage collection, you can also check out
this bibliography of garbage collection related papers:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cs.kent.ac.uk/people/staff/rej/gcbib/&quot;&gt;the Garbage Collection Bibliography&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I would also like to thank Michael R. Bernstein for reviewing this post.
He's been writing interesting blog posts on garbage collection and gave
a presentation at GoRuCo 2013. These articles can be really useful if
you want to have a starting point for the basic garbage collection
concepts that this article assumes you are somewhat familiar with.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://michaelrbernste.in/2013/05/20/adventures-in-GC-pedagogy.html&quot;&gt;Adventures in Garbage Collection Pedagogy and an Introduction to Racket&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://michaelrbernste.in/2013/06/10/to-know-a-garbage-collector-goruco-2013.html&quot;&gt;To Know A Garbage Collector: GoRuCo 2013&lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Better access to runtime information from Ruby</title>
    <id>http://rubini.us/2013/05/21/more-ruby-transparency/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2013/05/21/more-ruby-transparency/" />
    <updated>2013-05-21T00:00:00-05:00</updated>
    <author>
      <name>Dirkjan Bussink</name>
    </author>
    
    <content type="html">&lt;p&gt;Rubinius has always tried to provide a lot of information to you as a
developer about runtime information. Things like the variable scope and
constant scope are already available. In this post I'd like to describe
a small new API that is available for even more information.&lt;/p&gt;

&lt;h3&gt;Inline caching&lt;/h3&gt;

&lt;p&gt;One of the important mechanisms in making your Ruby code fast is doing
inline caching. Inline caching means that we store the result of a method
lookup a specific call site.&lt;/p&gt;

&lt;p&gt;So what is a call site you might ask? Well, that's every place in your
code where a method is called. So take for example the following
snippet.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Foo&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bar&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt;     &lt;span class=&quot;vi&quot;&gt;@foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;quz&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here &lt;code&gt;@foo.quz&lt;/code&gt; is a call site, so the place where quz is called. What we
do here is cache the type of &lt;code&gt;@foo&lt;/code&gt; and store which method to execute for
this type.&lt;/p&gt;

&lt;p&gt;The fact that inline caching works well is based on the idea that at
runtime for most call sites the receiver type never changes. So in this
case it means that &lt;code&gt;@foo&lt;/code&gt; is always of the same type. This is
called a monomorphic call site.&lt;/p&gt;

&lt;p&gt;Of course there are cases where this reasoning doesn't apply. If we see
multiple types at a certain call site, it's called a polymorphic call site.
For this we store things in a different object and Rubinius currently stores
up to 3 different types in that case.&lt;/p&gt;

&lt;p&gt;It might be surprising to some, but these cache objects are also just
Ruby objects. This means that they can be used just like any other Ruby
object and be inspected for example. So there are objects for an empty
call site, for monomorphic and also polymorphic sites.&lt;/p&gt;

&lt;p&gt;There is also a specialized site for places where we call &lt;code&gt;respond_to?&lt;/code&gt; since that
happens often enough to warrant a special case. In the future there
might be new types introduced such as a specific type for &lt;code&gt;send&lt;/code&gt; calls.&lt;/p&gt;

&lt;h3&gt;Accessing inline caches stored at call sites&lt;/h3&gt;

&lt;p&gt;So now that we have described all this, how do we get access to this
information? It is actually pretty straightforward and builds on other
things already available.&lt;/p&gt;

&lt;p&gt;Under the hood, all Ruby code in Rubinius gets translated into a
&lt;code&gt;CompiledCode&lt;/code&gt; object, which also provides the API for getting access to
inline caches. One way to get access to the &lt;code&gt;CompiledCode&lt;/code&gt; object is to
grab it through Ruby's Method API.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Foo&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bar&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt;     &lt;span class=&quot;vi&quot;&gt;@foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;quz&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compiled_code&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;executable&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compiled_code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;call_sites&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt;   &lt;span class=&quot;nb&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cs&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# #&amp;lt;Rubinius::CallSite:0xXX script.rb:3#quz(0)&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;What you can see here is that we have one call site located at &lt;code&gt;script.rb&lt;/code&gt;
on line 3 (which is the class definition). Currently it's of the type
&lt;code&gt;CallSite&lt;/code&gt;, which means that it has a basic structure in place with no
additional information because this method was never called. This can
also be inferred from the (0) at the end which indicates the number of
calls through this object.&lt;/p&gt;

&lt;p&gt;So if we make sure we call this at least once, we should be able to see
this information.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Foo&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bar&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt;     &lt;span class=&quot;vi&quot;&gt;@foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;quz&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;rescue&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compiled_code&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;executable&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compiled_code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;call_sites&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt;   &lt;span class=&quot;nb&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cs&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# #&amp;lt;Rubinius::MonoInlineCache:0xXX script.rb:3#quz(1)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;#   receiver_class=NilClass stored_module=Kernel&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;#   method=#&amp;lt;Rubinius::CompiledCode method_missing file=kernel/delta/kernel.rb&amp;gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;What we do here is actually run this inside a begin / rescue clause
because the call will fail because @foo being nil. But this will also
show that we can actually cache that this will run the &lt;code&gt;method_missing&lt;/code&gt;
method and that we cache that.&lt;/p&gt;

&lt;p&gt;What you can see here is that we have a &lt;code&gt;MonoInlineCache&lt;/code&gt;, because we've
only seen one type for &lt;code&gt;@foo&lt;/code&gt;, which is &lt;code&gt;nil&lt;/code&gt; so the receiver class is
&lt;code&gt;NilClass&lt;/code&gt;. The &lt;code&gt;stored_module&lt;/code&gt; is the module the saved method is in, which
in this case is &lt;code&gt;Kernel&lt;/code&gt;. The actual method stored is the &lt;code&gt;method_missing&lt;/code&gt;
method here. We can also see it has been called 1 time so far.&lt;/p&gt;

&lt;h3&gt;Caveats&lt;/h3&gt;

&lt;p&gt;Currently you get these objects back and you can actually modify them.
Modifying them at the moment would actually result in undefined
behavior. You can't do this easily though since they only provide
accessor readers, but since it's Ruby you can of course hack around with
&lt;code&gt;instance_variable_set&lt;/code&gt; for example.&lt;/p&gt;

&lt;p&gt;You can probably do really crazy stuff with this, if it crashes the vm
it's probably a bug, otherwise you're pretty much on your own when
hacking this.&lt;/p&gt;

&lt;p&gt;Another thing is that the counters are not guaranteed to be accurate.
This can mainly happen when the JIT kicks in. The JIT doens't update
counters if it inlines methods so that way the method could be called
more often than you'd think based on the counter. If it's zero though,
you can be sure it has been never called since it will always go through
the interpreter path first.&lt;/p&gt;

&lt;h3&gt;Future&lt;/h3&gt;

&lt;p&gt;So besides for fun and crazy, what is this actually useful for? Well,
first of all we already use it to actually test in Ruby whether our
inline caches work properly. This made testing this a lot easier and we
can easily verify that an empty call sites turns into a monomorphic
cache and subsequently in a polymorphic one if needed.&lt;/p&gt;

&lt;p&gt;Another reason this can be very useful is for building better tools.
With this information, it would be possible to create better
refactoring tools for example. The information provided here gives you
insight into which methods are bound where and could help perhaps in
renaming things.&lt;/p&gt;

&lt;p&gt;It would also be interesting to gather this information from your
runtime application, so you could see which code does and doesn't get
executed in your production environment. All these things are just
ideas, but API's like the one discussed here make these future
developments possible and allow for more insight in your Ruby code.&lt;/p&gt;

&lt;p&gt;So play with and let us know what you've done with it!&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Profiling JIT-ted Ruby code with OProfile</title>
    <id>http://rubini.us/2013/03/20/profiling-jitted-ruby-code-with-oprofile/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2013/03/20/profiling-jitted-ruby-code-with-oprofile/" />
    <updated>2013-03-20T00:00:00-05:00</updated>
    <author>
      <name>Ryo Onodera</name>
    </author>
    
    <content type="html">&lt;p&gt;You can now profile JIT-ted Ruby code!&lt;/p&gt;

&lt;p&gt;Before:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;samples  %        linenr info                 app name                 symbol name
497      28.7117  instructions.cpp:82         rbx                      rubinius::MachineCode::interpreter(rubinius::State*, rubinius::MachineCode*, rubinius::InterpreterCallFrame*)
460      26.5742  (no location information)   anon (tgid:4118 range:0xb581c000-0xb589c000) anon (tgid:4118 range:0xb581c000-0xb589c000)
  # =&amp;gt; The dark world of JIT-ted Ruby code
158       9.1277  jit_util.cpp:787            rbx                      rbx_set_local_depth
113       6.5280  block_environment.cpp:365   rbx                      rubinius::BlockEnvironment::call(rubinius::State*, rubinius::CallFrame*, rubinius::Arguments&amp;amp;, int)
102       5.8925  (no location information)   rbx                      __x86.get_pc_thunk.bx
93        5.3726  jit_util.cpp:848            rbx                      rbx_push_local_depth
71        4.1017  variable_scope.cpp:108      rbx                      rubinius::VariableScope::set_local(int, rubinius::Object*)
68        3.9284  block_environment.cpp:62    rbx                      rubinius::BlockEnvironment::invoke(rubinius::State*, rubinius::CallFrame*, rubinius::BlockEnvironment*, rubinius::Arguments&amp;amp;, rubinius::BlockInvocation&amp;amp;)
52        3.0040  variable_scope.cpp:126      rbx                      rubinius::VariableScope::get_local(int)
47        2.7152  variable_scope.cpp:100      rbx                      rubinius::VariableScope::set_local(rubinius::State*, int, rubinius::Object*)
45        2.5997  kind_of.hpp:153             rbx                      bool rubinius::kind_of&amp;lt;rubinius::Fiber&amp;gt;(rubinius::Object const*)
24        1.3865  shared_state.cpp:295        rbx                      rubinius::SharedState::checkpoint(rubinius::ManagedThread*)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;samples  %        linenr info                 app name                 symbol name
3468     27.0388  instructions.cpp:82         rbx                      rubinius::MachineCode::interpreter(rubinius::State*, rubinius::MachineCode*, rubinius::InterpreterCallFrame*)
3048     23.7642  loop.rb:7                   5060.jo                  _X_Object#forever$block@1
  # =&amp;gt; Wow, the name of JIT-ted Ruby code is shown along side C++ function symbols!
1044      8.1397  jit_util.cpp:848            rbx                      rbx_push_local_depth
947       7.3834  (no location information)   rbx                      __x86.get_pc_thunk.bx
916       7.1417  jit_util.cpp:787            rbx                      rbx_set_local_depth
781       6.0892  block_environment.cpp:365   rbx                      rubinius::BlockEnvironment::call(rubinius::State*, rubinius::CallFrame*, rubinius::Arguments&amp;amp;, int)
639       4.9821  block_environment.cpp:62    rbx                      rubinius::BlockEnvironment::invoke(rubinius::State*, rubinius::CallFrame*, rubinius::BlockEnvironment*, rubinius::Arguments&amp;amp;, rubinius::BlockInvocation&amp;amp;)
421       3.2824  variable_scope.cpp:108      rbx                      rubinius::VariableScope::set_local(int, rubinius::Object*)
389       3.0329  variable_scope.cpp:126      rbx                      rubinius::VariableScope::get_local(int)
326       2.5417  variable_scope.cpp:100      rbx                      rubinius::VariableScope::set_local(rubinius::State*, int, rubinius::Object*)
288       2.2454  shared_state.cpp:295        rbx                      rubinius::SharedState::checkpoint(rubinius::ManagedThread*)
283       2.2065  kind_of.hpp:153             rbx                      bool rubinius::kind_of&amp;lt;rubinius::Fiber&amp;gt;(rubinius::Object const*)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In short, you can tell how the machine code that the Rubinius JIT generates
performs.&lt;/p&gt;

&lt;p&gt;Not satisfied yet? Even annotated profile is supported! That means you can even
know how much time it spends on each line of Ruby code or even on each CPU
instruction:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* 
 * Total samples for file : &quot;/tmp/loop.rb&quot;
 * 
 *   5658 19.9436
 */


   718  2.5308 :def increment(i)
   482  1.6990 :  i + 1
               :end
               :
               :def forever
               :  i = 0
  2933 10.3384 :  loop do /* _X_Object#forever$block@1 total:   6990 24.6387 */
  1525  5.3754 :    i = increment(i)
               :  end
               :end
               :
               :forever
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We're using &lt;a href=&quot;http://oprofile.sourceforge.net/news/&quot;&gt;OProfile&lt;/a&gt;, a profiling
software. In this blog post, I'll show you how to profile using it!&lt;/p&gt;

&lt;h3&gt;What's OProfile?&lt;/h3&gt;

&lt;p&gt;It's a very useful profiling tool available on Linux. It's a sampling-based
one. That means there is absolutely no change to Rubinius and your Ruby code to
profile. Just run it as you normally do. Also, the overhead of profiling is
minimal.&lt;/p&gt;

&lt;p&gt;This is contrasted to measuring-based profiling. Rubinius's built-in profiler
and ruby-prof are both examples of measuring profilers. This means the overhead
is much bigger and can skew results because of that.&lt;/p&gt;

&lt;p&gt;Basically, it works by reporting how many individual profiled items are sampled
compared to the overall total samples. It doesn't measure elapsed time. It's
much like top command's individual processes' CPU % usage with far greater
flexibility. The actual profiled items can be any of C/C++ libraries, C/C++
functions, C/C++ source code lines, or CPU instructions.&lt;/p&gt;

&lt;p&gt;So, OProfile can't usually profile Ruby code because it works on CPU
instruction level. From OProfile, it can't tell which Ruby source code line
Rubinius currently executing from the CPU instructions. However, it can profile
JIT-ted Ruby code because Rubinius compiles it very down into the CPU
instructions by definition.&lt;/p&gt;

&lt;p&gt;OProfile works as a Linux kernel module. So, it's supported only for Linux.
Sadly, Ubuntu's OProfile and LLVM have bugs relating to this feature.
Apparently, there is no one using this. So you can say, we are really on the
cutting edge. ;)&lt;/p&gt;

&lt;p&gt;Anyway, we must work around these problems. But how? There are a few options.
:)&lt;/p&gt;

&lt;h3&gt;Setup (PPA: the super simple way; Ubuntu 12.10 only)&lt;/h3&gt;

&lt;p&gt;I prepared a &lt;a href=&quot;https://launchpad.net/~ryoqun/+archive/ppa&quot;&gt;PPA&lt;/a&gt; just for you.
Add it to your system. To be specific, run this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo add-apt-repository ppa:ryoqun/ppa
$ sudo apt-get update
$ sudo apt-get install oprofile llvm-3.1
$ sudo apt-get dist-upgrade # Upgrade preinstalled libllvm3.1 to the PPA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default, Rubinius doesn't use system-provided LLVM, so re-configure Rubinius
to use it and re-build Rubinius:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /path/to/rubinius-git-repository
$ rake clean
$ ./configure --llvm-config llvm-config-3.1
$ rake
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Done!&lt;/p&gt;

&lt;h3&gt;Setup (manual build: the hard way)&lt;/h3&gt;

&lt;p&gt;If you really want to build LLVM and OProfile manually or if you're using an
other Linux distribution and the distribution doesn't provide OProfile-enabled
 LLVM packages, manually build LLVM and OProfile like this:&lt;/p&gt;

&lt;p&gt;(I tested this on Ubuntu 12.10. Minor adjustments may be needed to build on
your environment)&lt;/p&gt;

&lt;p&gt;Build and Install OProfile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get build-dep oprofile # do equivalent thing on your distro.
$ cd /path/to/working-dir-to-build-things
$ wget http://prdownloads.sourceforge.net/oprofile/oprofile-0.9.8.tar.gz
$ tar -xf oprofile-0.9.8.tar.gz
$ cd oprofile-0.9.8
$ ./autogen.sh
$ ./configure --prefix /usr # LLVM has a build issue. So install to /usr
$ make
$ sudo make install
$ adduser oprofile # this is needed for profiling JITted code
$ opreport --version
  # =&amp;gt; opreport: oprofile 0.9.8 compiled on Mar  8 2013 00:57:08
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Build LLVM with OProfile support enabled and rebuild Rubinius:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get build-dep llvm # do equivalent thing on your distro.
$ cd /path/to/working-dir-to-build-things
$ wget http://llvm.org/releases/3.2/llvm-3.2.src.tar.gz
$ tar -xf llvm-3.2.src.tar.gz
$ cd llvm-3.2.src
$ ./configure --enable-optimized --disable-assertions --with-oprofile
$ make
$ sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the compilation of &lt;code&gt;OProfileWrapper.cpp&lt;/code&gt; fails like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;OProfileWrapper.cpp: In member function bool llvm::OProfileWrapper::checkForOProfileProcEntry():
OProfileWrapper.cpp:141:62: error: read was not declared in this scope
OProfileWrapper.cpp:142:24: error: close was not declared in this scope
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apply this patch, then, re-&lt;code&gt;make&lt;/code&gt; and continue:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;diff --git a/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp b/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp
index d67f537..7c0d395 100644
--- a/llvm-3.1-3.1/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp
+++ b/llvm-3.1-3.1/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp
@@ -29,6 +29,7 @@
 #include &amp;lt;dirent.h&amp;gt;
 #include &amp;lt;sys/stat.h&amp;gt;
 #include &amp;lt;fcntl.h&amp;gt;
+#include &amp;lt;unistd.h&amp;gt;

 namespace {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Phew, finally rebuild Rubinius!:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /path/to/rubinius-git-repository
$ rake clean
$ rm -rf vendor/llvm # If you build Rubinius with vendorized LLVM.
$ ./configure
$ rake
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Start OProfile&lt;/h3&gt;

&lt;p&gt;OProfile can be configured by a command called &lt;code&gt;opcontrol&lt;/code&gt;, not by a
configuration file, which are common.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo opcontrol --deinit
$ sudo modprobe oprofile timer=1      # Needed only inside VirtualBox VMs
$ echo 0 | sudo tee /proc/sys/kernel/nmi_watchdog
$ sudo opcontrol --no-vmlinux
$ sudo opcontrol --separete all
$ sudo opcontrol --start
$ sudo opcontrol --dump               # Flushes buffered raw profile data
$ opreport --merge all --threshold 1  # Prints the report of profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Setup is complete if you see an output from &lt;code&gt;opreport&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CPU: CPU with timer interrupt, speed 1858.39 MHz (estimated)
Profiling through timer interrupt
          TIMER:0|
  samples|      %|
------------------
    92127 67.6157 no-vmlinux
    21920 16.0880 rbx
     7950  5.8348 libc-2.15.so
     4068  2.9857 runner
     3429  2.5167 libstdc++.so.6.0.17
     2139  1.5699 cc1
     1416  1.0393 vm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Congratulations!&lt;/p&gt;

&lt;h3&gt;Run Ruby code!&lt;/h3&gt;

&lt;p&gt;To annotate Ruby code correctly, your current directory must be the top
directory of the Rubinius git repository:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /path/to/rubinius-git-repository
$ ./bin/benchmark ./benchmark/core/hash/bench_access.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Generate profile report&lt;/h3&gt;

&lt;p&gt;Let's check the profile report of the above benchmark.&lt;/p&gt;

&lt;p&gt;NOTE: try to run &lt;code&gt;opcontrol --dump&lt;/code&gt; at least once while running Rubinius if
JIT-ted Ruby code doesn't show in the profile report. OProfile automatically
dumps periodically, but if your Ruby process terminates too quickly, you
should manually run &lt;code&gt;opcontrol --dump&lt;/code&gt; while it's still alive.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo opcontrol --dump &amp;amp;&amp;amp; sudo opjitconv /var/lib/oprofile/ 0 0
$ opreport --merge all --threshold 1 image:./bin/rbx --symbols --debug-info \
    &amp;gt; /tmp/hash-access-symbols
$ opannotate --merge all --threshold 0.5 image:./bin/rbx --source \
    &amp;gt; /tmp/hash-access-source
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I'll omit but you can generate profile report of annotated assembly by passing
&lt;code&gt;--assembly&lt;/code&gt; to &lt;code&gt;opannotate&lt;/code&gt; instead of &lt;code&gt;--source&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Reset current profile&lt;/h3&gt;

&lt;p&gt;By default, OProfile keeps the profile data indefinitely. To reset it, run
this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo opcontrol --reset
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;How to read the profile result&lt;/h3&gt;

&lt;p&gt;Open &lt;code&gt;/tmp/hash-access-symbols&lt;/code&gt;, the content should be like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CPU: CPU with timer interrupt, speed 1860.42 MHz (estimated)
Profiling through timer interrupt
samples  %        linenr info                 app name                 symbol name
3571     31.5990  (no location information)   no-vmlinux               /no-vmlinux
619       5.4774  bench_access.rb:16          8295.jo                  _X_Object#__block__$block@7
599       5.3004  bench_access.rb:24          8295.jo                  _X_Object#__block__$block@11
531       4.6987  bench_access.rb:8           8295.jo                  _X_Object#__block__$block@1
457       4.0439  (no location information)   rbx                      __x86.get_pc_thunk.bx
318       2.8139  jit_util.cpp:787            rbx                      rbx_set_local_depth
298       2.6369  bench_access.rb:42          8295.jo                  _X_Object#__block__$block@20
277       2.4511  object.cpp:362              rbx                      rubinius::Object::hash(rubinius::State*)
236       2.0883  jit_primitives.cpp:4494     rbx                      jit_stub_object_hash
236       2.0883  tuple.cpp:36                rbx                      rubinius::Tuple::put(rubinius::State*, int, rubinius::Object*)
222       1.9644  inline_cache.cpp:696        rbx                      rubinius::InlineCache::check_cache_poly(rubinius::State*, rubinius::InlineCache*, rubinius::CallFrame*, rubinius::Arguments&amp;amp;)
197       1.7432  jit_util.cpp:848            rbx                      rbx_push_local_depth
187       1.6547  variable_scope.cpp:126      rbx                      rubinius::VariableScope::get_local(int)
179       1.5839  compiledcode.cpp:212        rbx                      rubinius::CompiledCode::specialized_executor(rubinius::State*, rubinius::CallFrame*, rubinius::Executable*, rubinius::Module*, rubinius::Arguments&amp;amp;)
162       1.4335  hash.rb:220                 8295.jo                  _X_Hash#key_index@15
147       1.3008  hash.rb:325                 8295.jo                  _X_Hash#values_at$block@13
143       1.2654  object.cpp:400              rbx                      rubinius::Object::hash_prim(rubinius::State*)
137       1.2123  (no location information)   libc-2.15.so             /lib/i386-linux-gnu/libc-2.15.so
127       1.1238  variable_scope.cpp:100      rbx                      rubinius::VariableScope::set_local(rubinius::State*, int, rubinius::Object*)
111       0.9822  inline_cache.cpp:576        rbx                      rubinius::InlineCache::check_cache_reference(rubinius::State*, rubinius::InlineCache*, rubinius::CallFrame*, rubinius::Arguments&amp;amp;)
108       0.9557  vm.cpp:175                  rbx                      rubinius::VM::new_object_typed_dirty(rubinius::Class*, unsigned int, rubinius::object_type)
99        0.8760  vm.cpp:207                  rbx                      rubinius::VM::new_young_tuple_dirty(unsigned int)
97        0.8583  array18.rb:6                8295.jo                  _X_Array#map@12
93        0.8229  integer.cpp:84              rbx                      rubinius::Integer::from(rubinius::State*, int)
90        0.7964  hash.rb:137                 8295.jo                  _X_Hash#[]@23
76        0.6725  array.cpp:205               rbx                      rubinius::Array::set(rubinius::State*, int, rubinius::Object*)
72        0.6371  linkedlist.cpp:27           rbx                      LinkedList::remove(LinkedList::Node*)
68        0.6017  tuple.cpp:64                rbx                      rubinius::Tuple::create(rubinius::State*, int)
57        0.5044  method_primitives.cpp:12327 rbx                      rubinius::Primitives::object_hash(rubinius::State*, rubinius::CallFrame*, rubinius::Executable*, rubinius::Module*, rubinius::Arguments&amp;amp;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can guess, symbol names beginning with &lt;code&gt;_X_&lt;/code&gt; is the JIT-ted Ruby code.
Many Ruby benchmark blocks are JIT-ted (like
&lt;code&gt;_X_Object#__block__$block@7&lt;/code&gt; at &lt;code&gt;bench_access.rb:16&lt;/code&gt;) and listed near the top.
Also, &lt;code&gt;_X_Array#map@12&lt;/code&gt; is a JIT-ted code of &lt;code&gt;Array#map&lt;/code&gt;. I'll explain the
format of the report using it as an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;97        0.8583  array18.rb:6                8295.jo                  _X_Array#map@12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;97&lt;/code&gt; is the number of counts OProfile found what Rubinius was executing, while
periodically sampling it.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;0.8583&lt;/code&gt; is the percentage to the total number of samples OProfile collected.
Note that summing all entries up doesn't equal to 100%, because &lt;code&gt;opreport&lt;/code&gt; only
reported the top part of whole profile result (by &lt;code&gt;--threshold 0.5&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rubinius/rubinius/blob/1d7d7b2e2880478776476089d4dd93fd97aff122/kernel/bootstrap/array18.rb#L6&quot;&gt;&lt;code&gt;array18.rb:6&lt;/code&gt;&lt;/a&gt;
is the source location where this method is defined (this is same as
&lt;code&gt;Method#source_location&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;&lt;code&gt;8295.jo&lt;/code&gt; is a special &lt;code&gt;app name&lt;/code&gt; for JIT-ted code. Usually &lt;code&gt;app name&lt;/code&gt; is the
name of file C/C++ functions reside in (shared libraries or executables).
So, for normal Rubinius' C++ functions, &lt;code&gt;app name&lt;/code&gt; is just &lt;code&gt;rbx&lt;/code&gt; because they
reside in &lt;code&gt;./bin/rbx&lt;/code&gt;. For JIT-ted Ruby code, there can be no meaningful &lt;code&gt;app
name&lt;/code&gt;, because JIT-ted Ruby code is generated at runtime and they reside in no
file, but only in memory. So, OProfile uses &lt;code&gt;*.jo&lt;/code&gt; as &lt;code&gt;app name&lt;/code&gt; in such cases.
And, &lt;code&gt;8295&lt;/code&gt; means this is profiled when running the process of PID 8295.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;_X_Array#map@12&lt;/code&gt; is the name of symbol for this entry of profile report
(duh!).&lt;/p&gt;

&lt;p&gt;Open &lt;code&gt;/tmp/hash-access-source&lt;/code&gt;, the content should be like this (I'll omit some
unimportant part, because this file is big):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* 
 * Total samples for file : &quot;kernel/common/hash18.rb&quot;
 * 
 *   4870 12.8904
 */

&amp;lt;credited to line zero&amp;gt;     19  0.0503 :
               :# -*- encoding: us-ascii -*-
               :
               :class Hash
               :
               :  include Enumerable
               :
...
               :
               :  class Bucket
               :    attr_accessor :key
               :
   633  1.6755 :    def match?(key, key_hash) /* _X_Hash::Bucket#match?@16     75  0.1985, _X_Hash::Bucket#match?@16     45  0.1191, total:    120  0.3176 */
    40  0.1059 :      case key
   218  0.5770 :      when Symbol, Fixnum
   319  0.8444 :        return key.equal?(@key)
               :      end
               :
               :      @key_hash == key_hash and (Rubinius::Type::object_equal(key, @key) or key.eql?(@key))
               :    end
               :  end
...
               :end
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You might wonder why &lt;code&gt;Hash::Bucket#match?&lt;/code&gt; has so many counts while this didn't
appear in the report for symbols. The reason is that the method is inlined to
each its callers (maybe many top-appearing JIT-ted Ruby blocks). How cool this
is! You can really know which Ruby code is actually taking too much time.&lt;/p&gt;

&lt;h3&gt;My last favor&lt;/h3&gt;

&lt;p&gt;I wish the official Ubuntu packages are fixed and there is no need to add any
PPA. I want it-just-works. I reported affecting bugs to Ubuntu's bug tracking
system. So, please vote it up for fixing (vote them with &quot;affects you?&quot;,
please!!):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://launchpad.net/bugs/1154025&quot;&gt;Bug 1154025&lt;/a&gt; Install PIC version of libbfd.a&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://launchpad.net/bugs/1148682&quot;&gt;Bug 1148682&lt;/a&gt; symbol lookup error: /usr/lib/libopagent.so: undefined symbol: bfd_init&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://launchpad.net/bugs/1148529&quot;&gt;Bug 1148529&lt;/a&gt; OProfile support is disabled&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Further profiling&lt;/h3&gt;

&lt;p&gt;There is new profiling tool on Linux: &lt;code&gt;perf&lt;/code&gt; and &lt;code&gt;operf&lt;/code&gt; (OProfile's new
command). I don't know them well, but certainly they will be useful for
profiling Rubinius.&lt;/p&gt;

&lt;p&gt;As a last note, this is partially based on &lt;a href=&quot;http://code.google.com/p/unladen-swallow/wiki/UsingOProfile&quot;&gt;Unladen Swallow's
information&lt;/a&gt;
of profiling LLVM-based JIT-ted code by OProfile.&lt;/p&gt;

&lt;p&gt;Happy profiling!&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">PDX Summit Recap</title>
    <id>http://rubini.us/2013/03/19/pdx-summit-recap/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2013/03/19/pdx-summit-recap/" />
    <updated>2013-03-19T00:00:00-05:00</updated>
    <author>
      <name>Brian Shirai</name>
    </author>
    
    <content type="html">&lt;p&gt;Last week, Dirkjan spent the week with me at the Engine Yard office in
Portland, OR. We wanted to discuss a variety of topics related to Rubinius
technology. We started the week by making the following list:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Inline cache&lt;/li&gt;
&lt;li&gt;JIT IR&lt;/li&gt;
&lt;li&gt;Performance of JIT'd code&lt;/li&gt;
&lt;li&gt;Extension API&lt;/li&gt;
&lt;li&gt;Concurrency and garbage collection&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;We spent the week mostly writing a ton of things on the whiteboard, discussing
them, erasing them, and writing a bunch more. Ultimately, we touched on all
the topics but we did not get to discussing the extension API in depth, so
we'll skip that one for now. I've &lt;a href=&quot;http://rubini.us/2013/03/13/welcome-dirkjan/&quot;&gt;previously
blogged&lt;/a&gt; about our inline cache
discussion. Here I'll summarize the rest of our discussions.&lt;/p&gt;

&lt;h2&gt;Just-in-time Compiler&lt;/h2&gt;

&lt;p&gt;The just-in-time (JIT) compiler that converts our virtual machine bytecode to
machine code is a fundamental part of making Ruby fast. It is also one of the
most complex components of Rubinius. It requires interfacing with the virtual
machine to get runtime data and coordinating with the garbage collector to
keep other runtime data structures consistent.&lt;/p&gt;

&lt;p&gt;We are able to leverage &lt;a href=&quot;http://llvm.org&quot;&gt;LLVM&lt;/a&gt; for especially difficult parts
of machine code generation, like instruction selection, instruction scheduling
and register allocation. However, the semantics of Ruby are so removed from
those of the underlying CPU that we have a lot of work we still need to do to
improve the quality of the machine code.&lt;/p&gt;

&lt;p&gt;One important component of this work is the ability to represent operations
that have Ruby semantics (but are not part of Ruby itself) in a way that we
can perform transformations on those operations. The &quot;not part of Ruby&quot; is
actually a bit fuzzy. The concept of object allocation is certainly a part of
Ruby. But the specific operation of reserving a region in the heap is
invisible to Ruby.&lt;/p&gt;

&lt;p&gt;There are a couple operations in particular that are critical to Ruby
performance, especially when emitting machine code from the JIT. Those
operations are type guards and object allocation. If our assumptions for the
particular type of a value hold, we want to emit the fewest number of guards
as possible and we want the largest contiguous sequence of machine
instructions that are valid under a specific guard.&lt;/p&gt;

&lt;p&gt;Likewise, if an object is allocated but does not get passed outside of the
code sequence we are compiling to machine code, and we can see there are no
other side effects, we may be able to avoid allocating the object. A good
example of this in Rubinius, where the core library is implemented in Ruby, is
the ByteArray object that is used by String. A ByteArray is a fixed vector of
8-bit bytes. If an intermediate operation on a String creates a ByteArray and
that object isn't used outside the JIT'd method, the JIT should be able to see
through the object creation and recognize that just some machine bytes are
being moved around or transformed. The ByteArray allocation can be elided.&lt;/p&gt;

&lt;p&gt;These two examples, type guards and object allocation, are just a couple
things we expect the JIT to do well. There are many others.&lt;/p&gt;

&lt;p&gt;Right now, our JIT converts the virtual machine bytecode directly into LLVM
IR. To support more sophisticated JIT transformations, we need a
representation in between bytecode and LLVM IR, which is one of the things we
will be working on.&lt;/p&gt;

&lt;p&gt;Another aspect of the JIT that needs an overhauls is the infrastructure around
running the JIT. It runs on a separate native thread with few synchronization
points. Since Rubinius has no global lock, and since we need a variety of
auxiliary threads for system operations (e.g. handling process signals,
running object finalizers, handling debugger events), we have some
infrastructure for handling the lifetimes of these auxiliary threads. This is
a particularly complicated aspect of Rubinius because when Ruby code calls
&lt;code&gt;fork()&lt;/code&gt; or &lt;code&gt;exec()&lt;/code&gt;, the Ruby code knows nothing about these auxiliary
threads. We have to be careful that state is maintained across these calls.
This component will be enhanced to better handle auxiliary threads that are
actually proper Ruby threads (all auxiliary threads are fundamentally Ruby
threads but not necessarily visible in Ruby). This will permit us to have
multiple, potentially completely different, JIT threads running
simultaneously.&lt;/p&gt;

&lt;h2&gt;Performance&lt;/h2&gt;

&lt;p&gt;For us as people, when our assumptions fail we often just blunder on making
fools of ourselves. Too bad we don't have a &quot;check your assumptions&quot; mode as
useful as the one we build into the JIT. In the JIT, if our assumptions fail
and we don't catch it, we're going to compute the wrong values or cause the
wrong actions to be performed.&lt;/p&gt;

&lt;p&gt;So, in the JIT, when our assumptions are wrong, we must change course. This
course change may be to go down a different path in the machine code or to
exit the machine code entirely and go back to the interpreter. Both paths have
significant performance implications.&lt;/p&gt;

&lt;p&gt;A reason to exit the machine code is that one significant aspect of generating
fast machine code is proper use of the type guards. If our assumptions about
the type of a value are wrong, simply exiting back to the interpreter means
that we don't pollute the LLVM IR with types that can inhibit LLVM
optimizations from being as effective. On the other hand, there are runtime
costs associated with both exiting to the interpreter and running the
interpreter instead of machine code. Also, if we exit the generate machine code
too often, we may trigger a de-opt, throwing away that version of the machine
code and requiring the JIT to create a new one.&lt;/p&gt;

&lt;p&gt;Another aspect of the performance of the machine code we emit is how we handle
virtual machine operations. Some aspects of running Ruby require very
low-level operations that we call primitives. These are coded in C++ and
interact with internal virtual machine facilities. When compiling machine
code, we want as few conditionals and as few function calls as possible to get
the highest performance. Typically, we call a function that performs the
primitive operation and then returns to the JIT'd machine code. As we move
more and more things into Ruby itself, it is possible for the JIT to inline
operations and get the greatest possible optimizations. This is another area
we will be working on as we improve the JIT.&lt;/p&gt;

&lt;h2&gt;Concurrency&lt;/h2&gt;

&lt;p&gt;One of the goals for Rubinius since the very beginning is to provide excellent
support for concurrency and parallelism in Ruby. We have already removed the
global interpreter lock (GIL/GVL) from Rubinius. However, we have to ensure
that we don't replace it with an effective global lock when we implement
components of the system.&lt;/p&gt;

&lt;p&gt;The key to improving lock-freedom throughout the system is to use less locks.
That may seem obvious, but it is not necessarily that simple. As I mentioned
above, the virtual machine actually uses a variety of threads internally. And
with no global lock, any Ruby thread could invoke any virtual machine
operation, like &lt;code&gt;fork()&lt;/code&gt;, at any time. Multiple Ruby threads could be calling
the same method on the same object at the same time. Considering my previous
post about inline caches, this implies that all sorts of data races and
concurrency bugs could arise just from calling Ruby methods.&lt;/p&gt;

&lt;p&gt;In the virtual machine, we must be careful to ensure correctness under
concurrent execution. The classical way of doing so is to use locking.
However, there is tons of research from the '90s about lock-free and wait-free
algorithms. This academic research is slowly trickling down to industry in
various domains. We will be using lock-free implementations of various virtual
machine data structures to improve support for concurrency and parallelism.&lt;/p&gt;

&lt;h2&gt;Garbage Collection&lt;/h2&gt;

&lt;p&gt;One particularly challenging area that requires careful control of concurrency
is the garbage collector. Rubinius provides a generational garbage collector
with very short pause times when collecting the young generation. The
generational architecture allows us to only collect a small region of the heap
instead of the whole heap every time. We also support object allocation using
thread-local buffers to avoid locking and contention when Ruby code is running
in parallel.&lt;/p&gt;

&lt;p&gt;However, the garbage collector architecture pauses all threads to perform a
collection. While the pause for a young generation collection is on the order
of a few milliseconds (5-15 in many cases), there is the overhead of forcing
all the various threads to pause.&lt;/p&gt;

&lt;p&gt;There is only one way to address this issue and that is to make the garbage
collector concurrent. Fortunately, we can achieve this with some modifications
to our existing garbage collector. When adding concurrency to the garbage
collector, we want to avoid slowing down non-garbage-collector operations,
typically referred to as mutator performance. (Operations in the system can be
viewed as partitioned into two sets: the heap management--allocation and
garbage collection, and the operations that mutate the heap--mutator
operations.)&lt;/p&gt;

&lt;p&gt;With modifications to our mature generation collector (based on the Immix
collector), we can perform partial heap collections and preserve the
generational benefits while also limiting stop-the-world pauses to specific
regions of the heap and bounding the pause times.&lt;/p&gt;

&lt;h2&gt;Semantic Versioning&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://semver.org/&quot;&gt;Semantic Versioning&lt;/a&gt; is a methodology for versioning
software to support correct dependency management. MRI has never had
particularly strong support for versioning, with semantic changes being added
in patch levels (not even visible in the RUBY_VERSION constant) and major
version increments on special dates completely devoid of semantic relevance.&lt;/p&gt;

&lt;p&gt;In Rubinius, we would like to provide a more sound versioning discipline, in
particular, semantic versioning. However, this raises some significant
challenges. Let's consider some of the components of Rubinius:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ruby language itself in one of three language modes: 1.8, 1.9, and 2.0&lt;/li&gt;
&lt;li&gt;Ruby core classes&lt;/li&gt;
&lt;li&gt;Ruby standard library&lt;/li&gt;
&lt;li&gt;MRI compatibility &quot;C-API&quot; for supporting C-extensions&lt;/li&gt;
&lt;li&gt;Supporting core classes like ByteArray and Tuple&lt;/li&gt;
&lt;li&gt;Bytecode compiler&lt;/li&gt;
&lt;li&gt;Virtual machine instruction set&lt;/li&gt;
&lt;li&gt;Internal APIs for JIT, garbage collection, concurrency management&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The key component on which semantic versioning is based is the public API. But
what is included in that? Is it just Ruby as covered in RubySpec? Is it also
our supporting Ruby classes or Ruby facilities like the parser and bytecode
compiler? Since Rubinius is a language platform used to implement other
programming languages besides Ruby, resolving these questions correctly is
important.&lt;/p&gt;

&lt;p&gt;Along with a sound versioning discipline, we also want to promote continuous
delivery of enhancements to Rubinius. Technically, these are compatible goals,
but require that we consider how to organize our development and source
branches when we create backward-incompatible API changes.&lt;/p&gt;

&lt;p&gt;As we work toward the Rubinius 2.0 release, we will do our best to implement
semantic versioning. You can help us by testing your applications, gems, or
libraries on Rubinius. One great place to do this, of course, is &lt;a href=&quot;https://travis-ci.org/&quot;&gt;Travis
CI&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;All Work and No Play&lt;/h2&gt;

&lt;p&gt;Portland is a beautiful city. It's not very big but has enough city things to
feel like a proper city. I didn't want to keep Dirkjan caged in the office all
day every day, so when the weather looked promising on Friday, we packed our
concurrency and garbage collection conversation up and headed out. First we
went to &lt;a href=&quot;http://www.pdx.edu/&quot;&gt;Portland State University&lt;/a&gt; to attend a talk at a
programming language club. The talk was on continuation-passing style,
defunctionalization, and transformations. It was somewhat related to our
compiler work and it was certainly interesting. But my real motive was to
introduce Dirkjan to my former coworker &lt;a href=&quot;https://twitter.com/larrytheliquid&quot;&gt;Larry
Diehl&lt;/a&gt;, who is a PhD student at PSU doing
fascinating work in dependently typed programming language theory.&lt;/p&gt;

&lt;p&gt;After the talk at PSU, we hopped on the MAX light rail and headed toward the
&lt;a href=&quot;http://japanesegarden.com/&quot;&gt;Japanese Garden&lt;/a&gt;. The bus that would take us the
rest of the way wasn't due for 25 minutes so we decided to walk. The garden is
located in Portland's &lt;a href=&quot;http://washingtonparkpdx.org/&quot;&gt;Washington Park&lt;/a&gt;, which
is located in the west hills of Portland. So, we walked, uphill, for quite a
while. We walked past the Lewis and Clark monument, through the &lt;a href=&quot;http://www.rosegardenstore.org/&quot;&gt;international
rose garden&lt;/a&gt;, past the tennis courts and
finally up another steep hill to the Japanese Garden.&lt;/p&gt;

&lt;p&gt;The Japanese Garden is one of the most beautiful and authentic outside of
Japan. We are very lucky to have it here and my wife and I visit it frequently
to enjoy the beautiful views and bask in the tranquility. Since it is early
spring, not many plants were blossoming yet, but we saw some huge koi, some
water falls, beautiful trees, and a stunning view of Portland. Unfortunately,
Mt Hood was hiding in the clouds that day.&lt;/p&gt;

&lt;p&gt;I'm not much of a photographer, but here are some pics from the trip.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://farm9.staticflickr.com/8516/8573161804_69e037f173_c.jpg&quot; alt=&quot;Dirkjan photographing from a bridge&quot; /&gt;
&lt;img src=&quot;http://farm9.staticflickr.com/8367/8573160544_466e14d2ec_c.jpg&quot; alt=&quot;Koi!&quot; /&gt;
&lt;img src=&quot;http://farm9.staticflickr.com/8378/8572067073_a0555e44bd_c.jpg&quot; alt=&quot;Plants!&quot; /&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Welcome Dirkjan!</title>
    <id>http://rubini.us/2013/03/13/welcome-dirkjan/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2013/03/13/welcome-dirkjan/" />
    <updated>2013-03-13T00:00:00-05:00</updated>
    <author>
      <name>Brian Shirai</name>
    </author>
    
    <content type="html">&lt;p&gt;I am excited to announce that &lt;a href=&quot;https://engineyard.com&quot;&gt;Engine Yard&lt;/a&gt; is
sponsoring &lt;a href=&quot;https://github.com/dbussink&quot;&gt;Dirkjan Bussink&lt;/a&gt; to work on Rubinius!&lt;/p&gt;

&lt;p&gt;A long time ago (around 2008) when Dirkjan first showed up in the Rubinius
project he was still a university student finishing his Masters degree. He let
me read a draft of his thesis on brain-computer interfaces. Dirkjan has been
helping out on Rubinius since then. Recently, he's been fixing concurrency,
garbage collection, and JIT issues.&lt;/p&gt;

&lt;p&gt;This week, Dirkjan is working from the Engine Yard office in Portland, OR.
We've got a list of topics that we're delving into to get ready for several
technology improvements in Rubinius. We started with a list of five things,
one for each day. Unfortunately, time always goes faster than we expect so
we've dropped one topic. I'll blog a summary of our discussions so you get an
idea of some of the big stuff coming in Rubinius.&lt;/p&gt;

&lt;p&gt;Our first discussion was about our inline cache mechanisms. An inline cache is
used at a method call location to speed up calling a method. The first time it
is called, the method is looked up. Subsequently, as long as the receiver is
the correct type, the same method can safely be used. This is a typical
execution-time versus memory size trade-off. We cache the method we found,
which saves time looking it up again at the expense of some additional memory
to store the method. As with all caches, we have to carefully consider cache
invalidation.  Let's use a quick code sample to illustrate the inline cache.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In the example above, the class &lt;code&gt;B&lt;/code&gt; inherits from &lt;code&gt;A&lt;/code&gt;, which provides the method
&lt;code&gt;a&lt;/code&gt;. If we call &lt;code&gt;a&lt;/code&gt; on an instance of &lt;code&gt;B&lt;/code&gt;, we look up the method and find it
in &lt;code&gt;A&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here, in the code representation for the call &lt;code&gt;b.a&lt;/code&gt;, we store an inline cache
object. As long as the type of object we see in &lt;code&gt;b&lt;/code&gt; is the same, we can safely
call the cached method &lt;code&gt;a&lt;/code&gt;. However, if the type of &lt;code&gt;b&lt;/code&gt; changes, for example,
because we define a method &lt;code&gt;a&lt;/code&gt; on class &lt;code&gt;B&lt;/code&gt; itself, we must invalidate the
cache and look up the method again.&lt;/p&gt;

&lt;p&gt;The inline cache can be very important for the speed of the virtual machine
executing Ruby code. However, the inline cache is also very important for our
just-in-time (JIT) compiler that generates machine code, completely avoiding
the VM interpreter. Since the inline cache records the types of the Ruby
objects seen at the call site, we can use that information in the JIT to
generate fast code as long as our assumptions about the object type are
correct.&lt;/p&gt;

&lt;p&gt;Since inline caches are so important, Dirkjan and I did a complete review of
our existing inline caching and analyzed how to improve it. The most important
thing for improving execution speed is to do less. And the best way to do less
is to reduce redundancy.&lt;/p&gt;

&lt;p&gt;We started our analysis with an enumeration of all the kinds of calls that we
see in Ruby. This is the list that we made:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;fixed-arity method send&lt;/li&gt;
&lt;li&gt;variadic method send&lt;/li&gt;
&lt;li&gt;&lt;code&gt;respond_to?&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kind_of?&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;fixed-arity &lt;code&gt;a.send&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;variadic &lt;code&gt;a.send&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;super&lt;/code&gt; with explicit arguments&lt;/li&gt;
&lt;li&gt;&lt;code&gt;super&lt;/code&gt; with implicit arguments&lt;/li&gt;
&lt;li&gt;&lt;code&gt;method_missing&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This list is all kinds of method sends that you can see directly in Ruby code.
We added to this list a few other things that are not in Ruby code:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;extension API calls&lt;/li&gt;
&lt;li&gt;method combinations like &lt;code&gt;A.new&lt;/code&gt; which reduces to &lt;code&gt;A.allocate.initialize&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;call_custom (a special Rubinius instruction)&lt;/li&gt;
&lt;li&gt;primitives (parts of Ruby functionality that must be implemented in the VM)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The next thing we did was look at the method call sites from the perspective
of the virtual machine. Certain method calls, like &lt;code&gt;respond_to?&lt;/code&gt; imply certain
VM operations. This perspective is very important. Sometimes people complain
that Ruby is too dynamic because you could, for example, alias &lt;code&gt;respond_to?&lt;/code&gt;
or &lt;code&gt;eval&lt;/code&gt; to some other name. Now any attempt to statically analyze Ruby fails
because you can't know ahead of time what the alias may be. This is actually
not an issue if you consider the perspective from the VM. No matter what the
method name is, the ultimate VM operation for looking up a method will
execute. By associating method call sites with a VM operation, we get more
insight into how best to structure the inline cache.&lt;/p&gt;

&lt;p&gt;The next part of our analysis involved looking at what values are stored in
the inline cache for the various types we enumerated, and what values are used
for cache invalidation. The purpose of this analysis is two-fold: correctness
and performance. We want to ensure that our cache invalidation is correct
but also not generating false positives (i.e. invalidating cases that are not
actually invalid). We also want to ensure that storing and updating the data
in the cache can be done efficiently.&lt;/p&gt;

&lt;p&gt;The final part of our analysis concerned the cardinality of the cache. In
object-oriented code, a method call site may be &lt;em&gt;monomorphic&lt;/em&gt; (only one type
is seen), &lt;em&gt;polymorphic&lt;/em&gt; (a small number of different types are seen), or
&lt;em&gt;megamorphic&lt;/em&gt; (a huge number of different types are seen). This perspective
can be very important for performance and for memory overhead. We don't want
to waste memory for sites that are monomorphic. Nor do we want the cache to be
thrashing when many different types are seen.&lt;/p&gt;

&lt;p&gt;In summary, we looked at these aspects of inline caches: method call site
types, VM operations that result from the method call, the kind of data cached
and cache invalidation, and the cardinality of the method call site. We'll be
taking the results of our discussion and implementing changes to our inline
caching over the next few weeks.&lt;/p&gt;

&lt;p&gt;If you get a chance, pop into the #rubinius IRC channel on freenode.net and
say hello to Dirkjan!&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Heroku (Cedar) + Rubinius 2 + Puma 2 in Three Easy Steps</title>
    <id>http://rubini.us/2013/02/26/heroku-cedar-rubinius-2-puma-2-in-three-easy-steps/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2013/02/26/heroku-cedar-rubinius-2-puma-2-in-three-easy-steps/" />
    <updated>2013-02-26T00:00:00-06:00</updated>
    <author>
      <name>Shane Becker</name>
    </author>
    
    <content type="html">&lt;h3&gt;tl;dr&lt;/h3&gt;

&lt;p&gt;It's now &lt;strong&gt;&lt;a href=&quot;https://github.com/rubinius/heroku-rbx-puma-rails-app&quot;&gt;very easy&lt;/a&gt;&lt;/strong&gt; to get a &lt;a href=&quot;https://devcenter.heroku.com/articles/rails3&quot;&gt;Rails app&lt;/a&gt; on &lt;a href=&quot;https://devcenter.heroku.com/articles/cedar&quot;&gt;Heroku's Cedar Stack&lt;/a&gt; running on &lt;a href=&quot;http://rubini.us&quot; title=&quot;Rubinius : Use Ruby&amp;#8482;&quot;&gt;Rubinius 2.0&lt;/a&gt; and &lt;a href=&quot;http://puma.io&quot; title=&quot;A Modern, Concurrent Web Server for Ruby - Puma&quot;&gt;Puma 2.0&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;The Backstory&lt;/h3&gt;

&lt;p&gt;The fine folks at Heroku have been adding support for using &lt;a href=&quot;http://gembundler.com&quot; title=&quot;Bundler: The best way to manage a Ruby application's gems&quot;&gt;Bundler&lt;/a&gt; to &lt;a href=&quot;https://devcenter.heroku.com/articles/ruby-versions&quot;&gt;specify which version of Ruby&lt;/a&gt; your app uses and even &lt;a href=&quot;https://blog.heroku.com/archives/2012/12/13/run_jruby_on_heroku_right_now&quot;&gt;to specify which Ruby&lt;/a&gt; it uses.&lt;/p&gt;

&lt;p&gt;I've checked in on the progress of using Rubinius with this same method every couple few months for the past year or so. I was always met with the same results... &lt;q&gt;&quot;not quite yet, we're working on it&quot;&lt;/q&gt;.&lt;/p&gt;

&lt;p&gt;Last night I was getting mentally packed for &lt;a href=&quot;https://waza.heroku.com/2013&quot;&gt;Waza&lt;/a&gt; later this week and decided to check in on the state of things so I could ask the right people the right questions in person when we're all together. Turns out that sometime between last time and this time, they've got things working. Boom diggity! And it's pretty ding-dang easy too! Double boom diggity!&lt;/p&gt;

&lt;h3&gt;The Build Up&lt;/h3&gt;

&lt;p&gt;I'm going to assume that if you want to use Rubinius 2.0 that you also have the good sense to want to use Puma 2.0. There are three very simple steps to get up and running with Rubinius 2.0 + Puma 2.0.&lt;/p&gt;

&lt;h4&gt;Step 1&lt;/h4&gt;

&lt;p&gt;Add the Puma gem to your &lt;code&gt;Gemfile&lt;/code&gt;.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/veganstraightedge/5041441.js&quot;&gt;&lt;/script&gt;


&lt;h4&gt;Step 2&lt;/h4&gt;

&lt;p&gt;Tell Heroku to use Puma as your web server in your &lt;code&gt;Procfile&lt;/code&gt;.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/veganstraightedge/0135a61335bc76b1d9d5.js&quot;&gt;&lt;/script&gt;


&lt;h4&gt;Step 3&lt;/h4&gt;

&lt;p&gt;Specify Rubinius as your Ruby engine in your &lt;code&gt;Gemfile&lt;/code&gt;.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/veganstraightedge/1fb7ff88e74567c6e2e6.js&quot;&gt;&lt;/script&gt;


&lt;h3&gt;The Breakdown&lt;/h3&gt;

&lt;p&gt;Once you've done those things, your workflow is the same as before.
&lt;code&gt;bundle update &amp;amp;&amp;amp; git commit -am &quot;Double boom diggity!&quot; &amp;amp;&amp;amp; git push heroku master&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If you're changing an existing app from Heroku's default Ruby (MRI 1.9.x) to Rubinius, you'll see a message like this when you &lt;code&gt;git push heroku master&lt;/code&gt;.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/veganstraightedge/5041986.js&quot;&gt;&lt;/script&gt;


&lt;p&gt;The important lines are &lt;code&gt;Old: ruby 1.9.3&lt;/code&gt; and &lt;code&gt;New: rubinius 2.0.0.rc1&lt;/code&gt;. After that, everything the same as before. The bundling starts, etc.&lt;/p&gt;

&lt;h3&gt;The Outro&lt;/h3&gt;

&lt;p&gt;That's it. You should now be up and running with Rubinius and Puma!&lt;/p&gt;

&lt;p&gt;If you have problems, say something in the comments with a link to a gist with your problem output. If you succeed and get up and running in production, let us in the comments too. Tell the world that you love Rubinius/Puma.&lt;/p&gt;

&lt;p&gt;I threw together this &lt;a href=&quot;https://github.com/rubinius/heroku-rbx-puma-rails-app&quot;&gt;quick and dirty Rails app&lt;/a&gt; from scratch deployed to Heroku to show all this in action. &lt;a href=&quot;http://heroku-rbx-puma-rails-app.herokuapp.com&quot; title=&quot;Using Rubinius &amp;amp; Puma on Heroku&quot;&gt;http://heroku-rbx-puma-rails-app.herokuapp.com&lt;/a&gt;. I also migrated an existing MRI 1.9.3 app ( &lt;a href=&quot;http://farmhouse.la&quot; title=&quot;The Farmhouse in Hollywood, California&quot;&gt;The Farmhouse site&lt;/a&gt; ) to Rubinius 2.0 to show the migration is easy too.&lt;/p&gt;

&lt;h3&gt;The Thank Yous&lt;/h3&gt;

&lt;p&gt;None of this would be possible without the hard work of &lt;a href=&quot;https://github.com/carllerche&quot;&gt;Carl Lerche&lt;/a&gt;, &lt;a href=&quot;https://github.com/wycats/&quot;&gt;Yehuda Katz&lt;/a&gt;, &lt;a href=&quot;https://github.com/indirect/&quot;&gt;Andr Arko&lt;/a&gt;, &lt;a href=&quot;https://github.com/hone&quot;&gt;Terrence Lee&lt;/a&gt; and the other contributors to &lt;a href=&quot;https://github.com/carlhuda/bundler&quot;&gt;Bundler&lt;/a&gt;. And a special thanks to Terrence Lee for his dutiful stewardship of the &lt;a href=&quot;https://github.com/heroku/heroku-buildpack-ruby/&quot;&gt;Heroku Ruby Buildpack&lt;/a&gt;. Once again, the awesome powers of Open Source make great things possible.&lt;/p&gt;

&lt;h3&gt;The Footnotes&lt;/h3&gt;

&lt;p&gt;As of this writing &quot;Rubinius 2.0&quot; actually means &quot;Rubinius 2.0.0.rc1&quot; and &quot;Puma 2.0&quot; actually means &quot;Puma 2.0.1&quot;. The net result is the same though.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Debugging scary crashes of Rubinius</title>
    <id>http://rubini.us/2012/01/04/debugging-rubinius/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2012/01/04/debugging-rubinius/" />
    <updated>2012-01-04T00:00:00-06:00</updated>
    <author>
      <name>Dirkjan Bussink</name>
    </author>
    
    <content type="html">&lt;p&gt;Bugs, we all are in the infinite fight of getting rid of them. Sometimes
they are trivial, other times a bit harder. In this video I'm going to
show how I have been debugging an issue that caused memory corruption of
your dear Ruby objects in Rubinius.&lt;/p&gt;

&lt;h3&gt;Background&lt;/h3&gt;

&lt;p&gt;It's a pretty long video clocking at 55 minutes but I'm trying to be
detailed in the discovery process. I'm explaining the steps I'm taking
along the way and explaining why I'm taking those.&lt;/p&gt;

&lt;p&gt;The real debugging process if of course littered with taking wrong turns
so please don't think I'm brilliant and able to zoom into the issue
immediately all the time. The video is not recorded as I was going
through it the first time, so I exactly knew where I was going and
which steps to take.&lt;/p&gt;

&lt;p&gt;If you want to look up some more information on GDB that I'm using
in the video, here are some links that explain some of the most
used commands in the video:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://sourceware.org/gdb/onlinedocs/gdb/Data.html&quot;&gt;GDB - Examining data&lt;/a&gt;
&lt;a href=&quot;http://sourceware.org/gdb/onlinedocs/gdb/Set-Watchpoints.html&quot;&gt;GDB - Setting watchpoints&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;During the video there's a part from 8:18 until 11:28 where it's just
watching a rebuild of Rubinius scrolling by. I'd suggest skipping it
since it's not very useful. I tried to remove it but after having
to reencode the video it only grew larger. If anyone has more skills
to fix that, please let us know!&lt;/p&gt;

&lt;h3&gt;Download&lt;/h3&gt;

&lt;p&gt;You can find the video on Vimeo:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://vimeo.com/34622441&quot;&gt;Watch on Vimeo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It's probably best to download the video and play it locally on your
machine. It's 453 MB so it might take a while.&lt;/p&gt;

&lt;p&gt;Please let us know if you find this useful, we might do more of them
in the future if there's interest!&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Contributing to Rubinius</title>
    <id>http://rubini.us/2011/10/18/contributing-to-rubinius/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2011/10/18/contributing-to-rubinius/" />
    <updated>2011-10-18T00:00:00-05:00</updated>
    <author>
      <name>Brian Ford</name>
    </author>
    
    <content type="html">&lt;p&gt;Implementing Ruby is a lot of hard work. The Rubinius project has been lucky
to have &lt;a href=&quot;http://it.isagit.com/rubinius/rubinius&quot;&gt;more than 240 contributors&lt;/a&gt;,
many with &lt;em&gt;hundreds&lt;/em&gt; of commits, including code, benchmarks, documentation,
translations, and more. Lately, we have seen a surge of new folks working hard
on 1.9 language features. While we concentrate on making Rubinius easy to
contribute to, this post should clarify some things and pave an easier road to
your first Rubinius commit.&lt;/p&gt;

&lt;h3&gt;Contributions&lt;/h3&gt;

&lt;p&gt;Before diving into the Rubinius code, I want to emphasize that there are many
ways that you can contribute to Rubinius. One of the most valuable for us is
trying your own library or application on Rubinius. We've worked super hard to
make using Rubinius in place of MRI as simple as possible. For example, with a
typical Rails application, here is all you should need to do to get set up:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rvm install rbx
rvm use rbx
gem install bundler
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you've got Rubinius and Bundler installed, running your application
should be this simple:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd &amp;lt;my_application&amp;gt;
rm Gemfile.lock
bundle install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the step of removing the &lt;code&gt;Gemfile.lock&lt;/code&gt;. This is necessary to force
bundler to resolve the dependencies for Rubinius. This is very important. Not
all gems for MRI will work with Rubinius, and in some cases Rubinius has
built-in gems or stubs that need to be considered when resolving dependencies
(ruby-debug and ffi are two examples).&lt;/p&gt;

&lt;p&gt;Once &lt;code&gt;bundle install&lt;/code&gt; is finished, you should be able to start your
application just like you would under MRI. If you have any trouble, please let
us know. Issues for Rubinius are &lt;a href=&quot;https://github.com/rubinius/rubinius/issues&quot;&gt;tracked on
Github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Another way to contribute to Rubinius is talking about the project. If you
tried your application and your 50 gems installed without problems, consider
&lt;a href=&quot;https://twitter.com/rubinius&quot;&gt;tweeting at us&lt;/a&gt; or writing up a quick blog post
about your experiences. If you've done something
&lt;a href=&quot;http://fancy-lang.org/&quot;&gt;fancy&lt;/a&gt; that you'd like to share with us, we're always
happy to have &lt;a href=&quot;http://rubini.us/2011/02/23/introduction-to-fancy/&quot;&gt;guest blog
posts&lt;/a&gt;, too. We even have
documentation on &lt;a href=&quot;http://rubini.us/doc/en/how-to/write-a-blog-post/&quot;&gt;how to write a blog
post&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Clone &amp;amp; Build&lt;/h3&gt;

&lt;p&gt;Before we can do anything else, we need to get the Rubinius source code and
build it. Run the commands below to do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git://github.com/rubinius/rubinius.git
cd rubinius
./configure
rake
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can run Rubinius directly from the build directory, there is no need to
install it. We provide symlinks for common commands like &lt;code&gt;gem&lt;/code&gt;, &lt;code&gt;rake&lt;/code&gt;, &lt;code&gt;irb&lt;/code&gt;,
&lt;code&gt;ri&lt;/code&gt;, &lt;code&gt;rdoc&lt;/code&gt;, and even &lt;code&gt;ruby&lt;/code&gt;. Just add &lt;code&gt;&amp;lt;rbx_clone&amp;gt;/bin&lt;/code&gt; to your &lt;code&gt;PATH&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If you run into any trouble with these steps, see the &lt;a href=&quot;http://rubini.us/doc/en/getting-started/&quot;&gt;Getting
Started&lt;/a&gt; page for more information.
You may need to install libraries required to build Rubinius. If you don't
find answers there, visit the &lt;code&gt;#rubinius&lt;/code&gt; channel on freenode.net and we'll
help you out.&lt;/p&gt;

&lt;p&gt;While the build is running, let's get a quick overview of how Rubinius is
organized.&lt;/p&gt;

&lt;h3&gt;Code Tour&lt;/h3&gt;

&lt;p&gt;There are two main divisions in the Rubinius source code. The virtual machine,
garbage collector, and just-in-time (JIT) compiler are written in C++. The
Ruby core library, bytecode compiler, and various tools like the profiler and
debugger are written mostly or all in Ruby.&lt;/p&gt;

&lt;h4&gt;Ruby Core Library&lt;/h4&gt;

&lt;p&gt;The Ruby core library is found in the &lt;code&gt;kernel/&lt;/code&gt; directory. The kernel is
divided into subdirectories that are loaded in order when Rubinius boots. The
divisions were made to help share the Ruby core library with other
implementations. I'll cover those basic divisions here. For more details about
how the loading process works, see the
&lt;a href=&quot;http://rubini.us/doc/en/bootstrapping/&quot;&gt;Bootstrapping&lt;/a&gt; documentation.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;alpha.rb&lt;/code&gt; - Sets up very basic Ruby features needed to start loading the
rest of the core library.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bootstrap/&lt;/code&gt;- Contains implementation-specific features needed to load the
main parts of the core library.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;platform/&lt;/code&gt; - Contains platform-specific features like the FFI
(foreign-function interface) code that is used extensively in Rubinius to
bind to standard &lt;code&gt;libc&lt;/code&gt; functions.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;common/&lt;/code&gt; - Contains the majority of the Ruby core library and the code
should be implementation-agnostic.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delta/&lt;/code&gt; - Contains more implementation-specific code that may extend or
override code from &lt;code&gt;common/&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Most of the work on the Ruby core library will be done in &lt;code&gt;kernel/common/&lt;/code&gt;.&lt;/p&gt;

&lt;h4&gt;Rubinius VM&lt;/h4&gt;

&lt;p&gt;The concept of a virtual machine is somewhat nebulous. It can be hard to draw
the lines around the different components. In Rubinius, the code for the
bytecode interpreter, garbage collector, and JIT compiler is under the &lt;code&gt;vm/&lt;/code&gt;
directory. There are subdirectories for the garbage collector (&lt;code&gt;vm/gc/&lt;/code&gt;) and
the JIT compiler (&lt;code&gt;vm/llvm/&lt;/code&gt;). The &lt;code&gt;main()&lt;/code&gt; function is in
&lt;code&gt;vm/drivers/cli.cpp&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;One of the important parts of Rubinius are the low-level operations that
cannot be defined in Ruby. These are things like adding two Fixnums together.
These operations are called primitives and the code for them is in
&lt;code&gt;vm/builtin&lt;/code&gt;. Since you will likely encounter these in the core library, we'll
delve into them a bit.&lt;/p&gt;

&lt;h4&gt;Primitives&lt;/h4&gt;

&lt;p&gt;All methods that can be called in Ruby are exposed as, well, Ruby methods. If
you open &lt;code&gt;kernel/bootstrap/fixnum.rb&lt;/code&gt;, you should see the following code:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;to_f&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;no&quot;&gt;Rubinius&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;primitive&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:fixnum_to_f&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;PrimitiveFailure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;Fixnum#to_f primitive failed&amp;quot;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;Rubinius.primitive :fixnum_to_f&lt;/code&gt; code looks like a normal Ruby method
call but it is not. It's actually a compiler directive to tag this Ruby method
as having an associated primitive operation. The name of the primitive is
&lt;code&gt;fixnum_to_f&lt;/code&gt;. This naming convention is standard, being composed of the class
name and the method name. Methods in Ruby that are characters, like &lt;code&gt;+&lt;/code&gt;, are
given word names for the primitives.&lt;/p&gt;

&lt;p&gt;When this method is run, the primitive operation is invoked. If the primitive
operation fails, the Ruby code following the &lt;code&gt;Rubinius.primitive&lt;/code&gt; line is run.
This code can perform any Ruby operation. For example, it may coerce the
arguments to a particular class and re-dispatch to itself. If no other
operation is appropriate, the method should raise an exception.&lt;/p&gt;

&lt;p&gt;To see how the Ruby method relates to the primitive code, open
&lt;code&gt;vm/builtin/fixnum.hpp&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Rubinius.primitive :fixnum_to_f&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;to_f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;STATE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;vm/builtin/*.hpp&lt;/code&gt; files are processed by the Rubinius build system to
automatically generate C++ code to resolve and bind these primitive
operations. The comment provides the link between the Ruby method and the C++
method.&lt;/p&gt;

&lt;p&gt;Finally, the actual implementation of this primitive is found in
&lt;code&gt;vm/builtin/fixnum.cpp&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fixnum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;STATE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_native&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here you can see that a new Float object is being created from the value of
the Fixnum. Rubinius names the C++ classes that implement the Ruby primitive
operations the same as their Ruby counterparts. One of the goals of Rubinius
is to build an elegant, easily comprehensible system, and we feel that this
consistency has been a great benefit toward that goal.&lt;/p&gt;

&lt;p&gt;Now that we have a basic idea of the structure of Rubinius, let's look at some
aspects of its runtime behavior, in particular, supporting different Ruby
language modes.&lt;/p&gt;

&lt;h3&gt;Language Modes&lt;/h3&gt;

&lt;p&gt;Rubinius 2.0 (the master branch) implements both 1.8 and 1.9 language features
in one executable. You can select the language mode at runtime by passing the
&lt;code&gt;-X18&lt;/code&gt; or &lt;code&gt;-X19&lt;/code&gt; flag, either as a command line option or by setting the
&lt;code&gt;RBXOPT&lt;/code&gt; environment variable. Both commands below should have the same
effect:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RBXOPT=-X19 bin/rbx -v
bin/rbx -X19 -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If I run that on my system, I will see the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rubinius 2.0.0dev (1.9.2 0f223599 yyyy-mm-dd JI) [x86_64-apple-darwin10.8.0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The default language mode is 1.8, so if you invoke &lt;code&gt;rbx&lt;/code&gt; with no other
options, you'll be running in 1.8 mode. You can change the default mode with a
configure time option as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./configure --default-version=1.9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you configure Rubinius to have a default language mode of 1.9, you can
access 1.8 mode with the &lt;code&gt;-X18&lt;/code&gt; runtime option as discussed above.&lt;/p&gt;

&lt;p&gt;Ok, we've got the code, we understand something about how it is organized,
we've got the runtime behavior down, now let's look at actually implementing
Ruby. To do that, we need to know how Ruby behaves, and that is what RubySpec
is all about.&lt;/p&gt;

&lt;h3&gt;By the Spec&lt;/h3&gt;

&lt;p&gt;Rubinius created the RubySpec project to ensure that we would be faithfully
implementing Ruby behavior, and we are constantly contributing more to it.
Basically, Rubinius does it by the spec. So, any commit to the Ruby core
library in Rubinius must either have new specs or make existing specs pass. To
effectively contribute to Rubinius, you'll need to understand some basics
about RubySpec. I recommend that you have a read through the documentation at
&lt;a href=&quot;http://rubyspec.org/&quot;&gt;rubyspec.org&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;RubySpec includes a custom-built framework for the specs called MSpec. The
syntax is intended to be consistent with &lt;a href=&quot;http://rspec.info&quot;&gt;RSpec&lt;/a&gt;, but there
are various facilities that are purpose-built to support multiple
implementations, multiple versions of Ruby, and multiple platforms.&lt;/p&gt;

&lt;h4&gt;Running Specs&lt;/h4&gt;

&lt;p&gt;MSpec provides several different scripts to run the specs under different
conditions. The default behavior is to simply run all the specs. If you invoke
the following command, it will run all the Ruby Array specs in the default
language mode, which should be 1.8 unless you configured 1.9 to be the
default:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bin/mspec core/array
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To Run the specs in 1.9 mode, add the &lt;code&gt;-tx19&lt;/code&gt; option:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bin/mspec -tx19 core/array
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;-t&lt;/code&gt; option specifies which target to run the specs under. The default in
Rubinius is to run them with Rubinius, so &lt;code&gt;-tx&lt;/code&gt; is implied. You can easily run
with another target by giving the name of an executable on your PATH or the
full path to an executable. Since the specs are intended to show the behavior
of MRI, if you are writing new specs you need to run them under MRI 1.8.7 and
1.9.2. I have those on my PATH, so I can do the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bin/mspec -t ruby1.8.7 core/array
bin/mspec -t ruby1.9.2 core/array
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, if you are running &lt;code&gt;bin/mspec&lt;/code&gt; in the Rubinius source directory, the
location of the RubySpecs are known (&lt;code&gt;spec/ruby/&lt;/code&gt;), so you can use the full
path or the shortened version &lt;code&gt;core/array&lt;/code&gt; above.&lt;/p&gt;

&lt;h4&gt;Continuous Integration&lt;/h4&gt;

&lt;p&gt;One goal of MSpec is to make it as easy as possible to run the specs for the
parts of Ruby that have been implemented. It takes a long time to implement
all of Ruby correctly, but we want to know that the parts we have implemented
don't get broken while working on other parts. That is the role of continuous
integration. To use CI effectively, we need to partition the specs into those
that we expect to pass and those we know we don't pass yet. MSpec provides a
facility for this, called tagging, that we'll look at shortly. For now, we'll
just look at running the specs in CI mode.&lt;/p&gt;

&lt;p&gt;To run all the Rubinius specs in CI mode under the default language version,
use the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bin/mspec ci
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Likewise, to run these specs in the 1.9 language mode, add the &lt;code&gt;-tx19&lt;/code&gt; option:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bin/mspec ci -tx19
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;bin/mspec ci&lt;/code&gt; command runs the &lt;code&gt;mspec-ci&lt;/code&gt; script. You should be familiar
with this mechanism from working with Git. It's the same idea. The &lt;code&gt;mspec&lt;/code&gt;
script itself is just a utility to invoke the various specific MSpec scripts.
To see the options for &lt;code&gt;mspec&lt;/code&gt;, run the following command&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bin/mspec -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are three basic functions that MSpec performs and these correspond to
&lt;code&gt;mspec-run&lt;/code&gt;, &lt;code&gt;mspec-ci&lt;/code&gt;, and &lt;code&gt;mspec-tag&lt;/code&gt;. When not given an operation, &lt;code&gt;mspec&lt;/code&gt;
assumes &lt;code&gt;run&lt;/code&gt;, so the following two commands are equivalent:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mspec core/array
mspec run core/array
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the operation is given, it must be the first parameter to &lt;code&gt;mspec&lt;/code&gt;. In the
case below, the first command runs &lt;code&gt;mspec-ci&lt;/code&gt; with &lt;code&gt;core/array&lt;/code&gt; while the
second command runs &lt;code&gt;mspec-run&lt;/code&gt; with &lt;code&gt;core/array&lt;/code&gt; and &lt;code&gt;ci&lt;/code&gt; as files.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mspec ci core/array
mspec core/array ci
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we've got the basics of MSpec down, let's look at how we find specs
that fail on Rubinius. To do this, we'll use the &lt;code&gt;mspec tag&lt;/code&gt; command.&lt;/p&gt;

&lt;h4&gt;Tagged Specs&lt;/h4&gt;

&lt;p&gt;Since Rubinius uses the tagging mechanism to create the set of CI specs to
run, the best way to discover what parts of RubySpec that Rubinius isn't
passing yet is to list the specs that are tagged. There's a command for that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bin/mspec tag --list fails -tx19 :ci_files
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command lists all the specs that are tagged as failing. There's some new
syntax here, namely &lt;code&gt;:ci_files&lt;/code&gt;. MSpec has the concept of pseudo-directories.
Basically, they are lists of files. The reason for this is that running all
the core or standard library specs in RubySpec is not as simple as just
running all the files under &lt;code&gt;spec/ruby/core&lt;/code&gt; or &lt;code&gt;spec/ruby/library&lt;/code&gt;. It's more
complicated than that because there are 1.8- and 1.9-specific libraries.
Rather than wrapping everything in &lt;code&gt;ruby_version_is&lt;/code&gt; guards, MSpec adds
version-specific lists and names them, for example, &lt;code&gt;:core&lt;/code&gt; and &lt;code&gt;:library&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this case, we're using the list of files specified by &lt;code&gt;:ci_files&lt;/code&gt;. This
list excludes some files that are known to cause problems if they are run.&lt;/p&gt;

&lt;p&gt;The list of specs that are currently marked as failing is pretty long. We can
reduce the number of tags we are looking at by giving a smaller set of specs
to run.  For example, let's just run the File specs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bin/mspec tag --list fails -tx19 core/file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looking at the output from this command, we notice (at least at the time of
writing this post) that there are several failures in the
&lt;code&gt;File.world_writable?&lt;/code&gt; specs. We can run just these specs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bin/mspec tag --list fails -tx19 core/file/world_writable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we look into the documentation for &lt;code&gt;File.world_writable?&lt;/code&gt;, we'll find that
it is a new method introduced in 1.9. Excellent, this gives us an opportunity
to talk about language-specific changes in Rubinius.&lt;/p&gt;

&lt;h3&gt;Language-specific Changes&lt;/h3&gt;

&lt;p&gt;When Rubinius boots, it loads different files depending on what language mode
it is running. In the &lt;code&gt;kernel/**/&lt;/code&gt; directories, there are &lt;code&gt;load_order18.txt&lt;/code&gt;
and &lt;code&gt;load_order19.txt&lt;/code&gt; files. These files are used during the build process to
create separate runtime kernels for Rubinius. You can see these in the
&lt;code&gt;runtime/18&lt;/code&gt; and &lt;code&gt;runtime/19&lt;/code&gt; directories after building.&lt;/p&gt;

&lt;p&gt;Here's how language-specific features are handled in the Rubinius kernel.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;If there are no language-specific methods, the name of the file in
&lt;code&gt;kernel/common&lt;/code&gt; is the name of the class. In the case here, the file is
&lt;code&gt;kernel/common/file.rb&lt;/code&gt;. This rule applies regardless of whether the class
is 1.8- or 1.9-specific. For example, Rational is part of the 1.9 core
library, but does not exist in the core library in 1.8. The Rational class
is in &lt;code&gt;kernel/core/rational.rb&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If there are version-specific methods, they go in &lt;code&gt;kernel/common/file18.rb&lt;/code&gt;
and &lt;code&gt;kernel/common/file19.rb&lt;/code&gt;. The correct file is then added to the
appropriate &lt;code&gt;load_orderNN.txt&lt;/code&gt; file.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;In the case of &lt;code&gt;File.world_writable?&lt;/code&gt;, there is no 1.8 version. So, we open
&lt;code&gt;kernel/common/file19.rb&lt;/code&gt; and add the method definition. After changing any of
the &lt;code&gt;kernel/**/*.rb&lt;/code&gt; files, we have to build Rubinius. Run the following
command to do that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rake build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After making the change, we verify that the specs pass by running the specs
&lt;em&gt;without&lt;/em&gt; the CI tags:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bin/mspec -tx19 core/file/world_writable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If all the specs pass, then you're ready to remove the CI tags. To do so, run
the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bin/mspec tag --del fails -tx19 core/file/world_writable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After removing the CI tags, the final step is to ensure that all specs still
pass. To run all the CI specs in both 1.8 and 1.9 modes, simply do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rake
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If everything passes, you're ready to submit a pull request. All in all, that
wasn't too bad, right?&lt;/p&gt;

&lt;p&gt;One final note, if you are making changes to RubySpec, make separate commits
in your pull request for changes to &lt;code&gt;spec/ruby/**/*_specs.rb&lt;/code&gt; and another
commit for any other Rubinius files. It is fine to commit the removed tags
with the other Rubinius changes.&lt;/p&gt;

&lt;h3&gt;Wrapping Presents&lt;/h3&gt;

&lt;p&gt;The information here should give you everything you need to get your feet wet
in Rubinius. By the way, today is Evan's birthday. If you're not taking him to
dinner, why don't you show your appreciation for this fantastic project he
created by grabbing Rubinius and hacking on some Ruby code. Be safe and have
fun! We can't wait to hear from you.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Matz and Me at RubyConf 2011</title>
    <id>http://rubini.us/2011/10/11/matz-and-me-at-rubyconf-2011/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2011/10/11/matz-and-me-at-rubyconf-2011/" />
    <updated>2011-10-11T00:00:00-05:00</updated>
    <author>
      <name>Shane Becker</name>
    </author>
    
    <content type="html">&lt;p&gt;I had a great time at RubyConf 2011 in New Orleans, LA. I saw old friends from all over the world. I met new friends from all over the world. We laughed and shared our dreams with each other. I gave away a huge pile of &lt;a href=&quot;http://store.americanapparel.net/tr401.html&quot; title=&quot;Tri-Blend Short Sleeve Track Shirt&quot;&gt;super soft t-shirts&lt;/a&gt;. I heard from many of you a pledge to go back to work and deploy something meaningful on Rubinius in production (more on that soon).&lt;/p&gt;

&lt;p&gt;Oh, and we took these pictures of me and Matz in the new Rubinius shirt. Altogether, not a bad conference at all.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.flickr.com/photos/veganstraightedge/6234562423&quot;&gt;&lt;img src=&quot;http://farm7.static.flickr.com/6232/6234562423_2c2c5b5f8b_z.jpg&quot; alt=&quot;Me with Matz in a Rubinius shirt at RubyConf 2011 in New Orleans, LA&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;http://www.flickr.com/photos/veganstraightedge/6234562147&quot;&gt;&lt;img src=&quot;http://farm7.static.flickr.com/6048/6234562147_d986abe428_z.jpg&quot; alt=&quot;Matz in a Rubinius shirt at RubyConf 2011 in New Orleans, LA&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;How was &lt;em&gt;your&lt;/em&gt; RubyConf?&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Steve Klabnik Thinks Rubinius is Awesome</title>
    <id>http://rubini.us/2011/10/04/steve-klabnik-thinks-rubinius-is-awesome/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2011/10/04/steve-klabnik-thinks-rubinius-is-awesome/" />
    <updated>2011-10-04T00:00:00-05:00</updated>
    <author>
      <name>Shane Becker</name>
    </author>
    
    <content type="html">&lt;p&gt;Steve Klabnik &lt;a href=&quot;https://github.com/rubinius/rubinius/pull/1184&quot;&gt;added support for &lt;code&gt;require_relative&lt;/code&gt; to Rubinius&lt;/a&gt;. He documents his process and &lt;a href=&quot;http://blog.steveklabnik.com/2011/10/04/rubinius-is-awesome.html&quot; title=&quot;Rubinius Is Awesome - Literate Programming&quot;&gt;how much fun he had&lt;/a&gt;. We're glad to hear that Steve thinks Rubinius is awesome. Making Rubinius awesome for rubyists has always been one of our core tenets.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Even if I didnt have some code to look at, because Rubinius is just Ruby,
it was really easy to dive in and check out the code, because its all Ruby.
Seriously. Rubinius is just Ruby. Just Ruby. Ruby.&lt;/p&gt;

&lt;p&gt;So dive in and add some features today! If having an awesome alternate Ruby implementation
isnt enough for you, the rbx team will bribe you with special stickers for committers, and sweet
black-on-black tshirts for people with 10 commits or more!&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.steveklabnik.com/2011/10/04/rubinius-is-awesome.html&quot; title=&quot;Rubinius Is Awesome - Literate Programming&quot;&gt;Read all about it on his blog Literate Programming&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Dr Nic Interviewed by Obie Fernandez about Rails, RailsInstaller, Ruby Virtual Machines and More</title>
    <id>http://rubini.us/2011/09/06/drnic-interview/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2011/09/06/drnic-interview/" />
    <updated>2011-09-06T00:00:00-05:00</updated>
    <author>
      <name>Shane Becker</name>
    </author>
    
    <content type="html">&lt;blockquote&gt;&lt;p&gt;Dr Nic Williams talks about the state of the Rails community, the reasons
for supporting JRuby and Rubinius implementations and for creating Rails
Installer.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/interviews/drnic-rails-ruby-vm&quot; title=&quot;InfoQ: Dr Nic Williams on Rails, RailsInstaller and the Future of Ruby VMs&quot;&gt;Watch and listen on InfoQ&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Retiring (Some) Rubinius Rewards</title>
    <id>http://rubini.us/2011/09/02/retiring-some-rubinius-rewards/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2011/09/02/retiring-some-rubinius-rewards/" />
    <updated>2011-09-02T00:00:00-05:00</updated>
    <author>
      <name>Shane Becker</name>
    </author>
    
    <content type="html">&lt;h3&gt;Bad News First&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&quot;http://www.flickr.com/photos/veganstraightedge/5709097384&quot; title=&quot;Rubinius &amp;quot;Use Ruby&amp;quot; TShirts at the Farmhouse in Hollywood, CA&quot;&gt;General Availability shirts&lt;/a&gt; are retired. We gave out about 1,000 to people all over the world. That's very awesome. We're really happy with the excitement about Rubinius from you all. Thank you, again. But it's time to move on from these shirts. If you've already got one, good on you. If you haven't yet, sorry. There will be other chances in the future, though.&lt;/p&gt;

&lt;p&gt;Likewise, the &lt;a href=&quot;http://asset.rubini.us/web/images/blog/rubinius_square_sticker.png&quot;&gt;Square&lt;/a&gt; and &lt;a href=&quot;http://asset.rubini.us/web/images/blog/rubinius_bumper_sticker.png&quot;&gt;Bumper Stickers&lt;/a&gt; have been retired, too.&lt;/p&gt;

&lt;h3&gt;Good News Next&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&quot;http://asset.rubini.us/web/images/blog/rubinius_diecut_sticker.png&quot;&gt;Diecut R stickers&lt;/a&gt; are still available. Just email us at &lt;a href=&quot;mailto:community@rubini.us&quot;&gt;community@rubini.us&lt;/a&gt; if you want one. &lt;a href=&quot;http://asset.rubini.us/web/images/blog/rubinius_alumni_sticker.png&quot;&gt;Committers stickers&lt;/a&gt; are still available too. If you committed to Rubinius before May 16, 2011 and haven't received one of these, &lt;a href=&quot;mailto:community@rubini.us&quot;&gt;email us&lt;/a&gt; to get yours. The 2011 Q2 committers stickers are also available.&lt;/p&gt;

&lt;p&gt;As &lt;a href=&quot;http://rubini.us/2011/05/26/rubinius-rewards/#tenth-commit-shirt&quot; title=&quot;Announcing Rubinius Rewards - Rubinius&quot;&gt;promised&lt;/a&gt;, we have made a special t-shirt for people who have committed 10 or more times. They're at the printer right now, so no pictures yet. Here's a hint though: black on black.&lt;/p&gt;

&lt;p&gt;We'll continue to do free stuff in the future, but it will always be changing. Keep an eye on this blog for updates to what's available.&lt;/p&gt;

&lt;h3&gt;One More Thing&lt;/h3&gt;

&lt;p&gt;Rubinius friend of the family, &lt;a href=&quot;http://hrrrthrrr.com&quot; title=&quot;hrrrthrrr&quot;&gt;Heather Peterson&lt;/a&gt; (&lt;a href=&quot;http://twitter.com/hrrrthrrr&quot;&gt;@hrrrthrrr&lt;/a&gt;) drew up some Rubinius sketches for us to use on upcoming t-shirts and stickers. As a little thing, we're giving away her original artwork as prize.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://flickr.com/veganstraightedge/6106800183&quot; title=&quot;Rubinius sketch by Heather Peterson (@hrrrthrrr)&quot;&gt;&lt;img src=&quot;http://farm7.static.flickr.com/6186/6106800183_f6bd6918f4_z.jpg&quot; alt=&quot;Rubinius sketch by Heather Peterson (@hrrrthrrr) on Flickr&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://flickr.com/veganstraightedge/6106803145&quot; title=&quot;Rubinius sketch by Heather Peterson (@hrrrthrrr)&quot;&gt;&lt;img src=&quot;http://farm7.static.flickr.com/6072/6106803145_f565d6738e_z.jpg&quot; alt=&quot;Rubinius sketch by Heather Peterson (@hrrrthrrr) on Flickr&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To enter, write a blog post about Rubinius and tweet at &lt;a href=&quot;http://twitter.com/rubinius&quot;&gt;@rubinius&lt;/a&gt; with a link to your post by Wednesday, September 7, 2011 Midnight PDT. Posts will be judged by me (Shane Becker), Evan Phoenix and Brian Ford. The winner will be announced on Friday September 9, 2011. All entrants will be linked to from &lt;a href=&quot;http://rubini.us/blog&quot; title=&quot;Rubinius : Use Ruby&amp;#8482;&quot;&gt;the Rubinius blog&lt;/a&gt; and &lt;a href=&quot;http://twitter.com/rubinius&quot;&gt;@rubinius&lt;/a&gt; Twitter account.&lt;/p&gt;

&lt;p&gt;Get blogging.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;mdash; XOXO RBX&lt;/em&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Rubinius - Now in The Third Dimension</title>
    <id>http://rubini.us/2011/08/30/rubinius-3d/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2011/08/30/rubinius-3d/" />
    <updated>2011-08-30T00:00:00-05:00</updated>
    <author>
      <name>Shane Becker</name>
    </author>
    
    <content type="html">&lt;p&gt;A long time ago, &lt;a href=&quot;http://twitter.com/bookis&quot; title=&quot;@bookis on Twitter&quot;&gt;Bookis Smuin&lt;/a&gt; crafted up a 3-dimensional representation of the little Rubinius &lt;em&gt;r&lt;/em&gt; logo. It was used on the Rubinius website and as the avatar for the &lt;a href=&quot;http://twitter.com/#!/rubinius&quot; title=&quot;@Rubinius on Twitter&quot;&gt;@Rubinius&lt;/a&gt; account. And for awhile, things were good.&lt;/p&gt;

&lt;p&gt;Somewhere along the way, the original files were lost. That left us with only PNG that was 239px wide. That's no good. To the Twitters!&lt;/p&gt;

&lt;p&gt;I &lt;a href=&quot;http://twitter.com/#!/veganstraightedge/status/101149379880157184&quot; title=&quot;Plea for 3D Help on Twitter&quot;&gt;lazy tweeted&lt;/a&gt; asking for help re-building the logo in 3D based on the work that Bookis did. Lo and behold, I asked and the internet delivered.&lt;/p&gt;

&lt;p&gt;The very smart and good looking Roger Bacardit (&lt;a href=&quot;http://twitter.com/ruxii&quot; title=&quot;@ruxii on Twitter&quot;&gt;@ruxii&lt;/a&gt;) from &lt;a href=&quot;http://codegram.com&quot; title=&quot;Codegram - Smart Web Apps&quot;&gt;Codegram&lt;/a&gt; in Barcelona, Espa&amp;ntilde;a stepped up to tackle the task. Lickity split, he cranked out two versions (white on black and black on white) at super mega huge resolution (~4000px square).&lt;/p&gt;

&lt;p&gt;Like everything else we do, &lt;a href=&quot;https://github.com/rubinius/collateral/tree/master/logos/3D&quot;&gt;these logo files&lt;/a&gt; are &lt;a href=&quot;https://github.com/rubinius/collateral/blob/master/README.md&quot;&gt;very liberally licensed&lt;/a&gt; and available for download and reuse in the &lt;a href=&quot;https://github.com/rubinius/collateral&quot;&gt;Rubinius Collateral repo&lt;/a&gt; over on GitHub.&lt;/p&gt;

&lt;p&gt;Thank you, Bookis, for the original.
Thank you, Roger, for the rebuild.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;mdash; XOXO RBX&lt;/em&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">&amp;#35;rbxday Blog Posts</title>
    <id>http://rubini.us/2011/08/05/rbxday-blog-posts/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2011/08/05/rbxday-blog-posts/" />
    <updated>2011-08-05T00:00:00-05:00</updated>
    <author>
      <name>Shane Becker</name>
    </author>
    
    <content type="html">&lt;p&gt;With just a few hours left in the first &lt;a href=&quot;http://rbxday.rubini.us&quot;&gt;#rbxday&lt;/a&gt;,
I wanted to share a few blog posts that people have written for today.
It seems like lots of people are having lots of fun all while using Rubinius.
That&amp;rsquo;s what really matters.&lt;/p&gt;

&lt;p&gt;And I think &lt;a href=&quot;http://twitter.com/andrewwk&quot;&gt;Andrew W. K.&lt;/a&gt;
would probably be proud of that.&lt;/p&gt;

&lt;p&gt;Onto the blog posts...&lt;/p&gt;

&lt;p&gt;Nathan Engdahl on the
&lt;a href=&quot;http://bluebox.net/news/2011/08/rubinius-day&quot; title=&quot;Rubinius Day&quot;&gt;Blue Box Group blog&lt;/a&gt;
writes:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;What is Rubinius you ask? Quite simply, its an alternative implementation
of Ruby, written in Ruby, designed for modern web developers. It provides
tools for simpler development of web applications. Rubinius strives for a
particularly fast and optimized implementation, ensuring applications run
at peak efficiency.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Chris White &lt;a href=&quot;http://rubysource.blogspot.com/2011/08/taking-byte-out-of-ruby.html&quot; title=&quot;A Source For All Things Ruby: Taking A Byte Out of Ruby&quot;&gt;compares bytecode&lt;/a&gt;
from MRI, JRuby and Rubinius:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Many developers don&amp;rsquo;t think too much about what&amp;rsquo;s going on behind the
scenes when they run their Ruby code. That&amp;rsquo;s the beauty of it, easy to
write code that&amp;rsquo;s given to Ruby and run for the developer. At some point
the developer may wonder, what&amp;rsquo;s REALLY going on behind the scenes. How is
it that something meant to run Ruby can host &lt;a href=&quot;http://rubini.us/projects&quot; title=&quot;&quot;&gt;so many other languages&lt;/a&gt;?
The answer lies in what&amp;rsquo;s known as a VM, or Virtual Machine.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Finally, there&amp;rsquo;s the
&lt;a href=&quot;http://rubysfera.pl/2011/08/kod-zrodlowy-rubiego-w-rubym/&quot; title=&quot;Kod rdowy Rubiego w Rubym&quot;&gt;Rubysfera blog&lt;/a&gt;
that&amp;rsquo;s not written in a language that I can read. So, I&amp;rsquo;ll just assume that
they&amp;rsquo;re talking about Chocolate Rubinius Cake and how to bake it. ;)&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Rubiniusa (implementacji Rubiego, napisanej w Rubym) nikomu chyba
przedstawia nie trzeba. Obecnie obsugiwana jest wersja jzyka 1.8.7, a
niektre benchmarki pokazuj, e Rubinius w tej wersji moe osiga szybko
porwnywaln z JRuby. Benchmarki, benchmarkami, najciekawsza jest moliwo
zajrzenia do implementacji jzyka w Rubym.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Seriously though, I have no idea what that post says.
If you do, please let me know.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s still time. Go test your app running on Rubinius. Tweet about it.
Use the hashtag &lt;a href=&quot;https://twitter.com/#!/search/%23rbxday&quot;&gt;#rbxday&lt;/a&gt;, so we
notice you and re-share your tweet. If there are bugs, please
&lt;a href=&quot;https://github.com/rubinius/rubinius/issues&quot;&gt;create an issue&lt;/a&gt; on Github.
Give us any other feedback you want on the
&lt;a href=&quot;http://rbxday.rubini.us/feedback&quot;&gt;rbxday.rubini.us&lt;/a&gt; website.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;mdash; XOXO RBX&lt;/em&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">&amp;#35;rbxday In Real Life</title>
    <id>http://rubini.us/2011/08/03/rbxday-in-real-life/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2011/08/03/rbxday-in-real-life/" />
    <updated>2011-08-03T00:00:00-05:00</updated>
    <author>
      <name>Brian Ford</name>
    </author>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;UPDATE:&lt;/strong&gt; &lt;em&gt;We have added several locations since this post was first
published. See the list below for all the current details. Also, stay tuned to
the official &lt;a href=&quot;http://rbxday.rubini.us&quot;&gt;rbxday.rubini.us&lt;/a&gt; website for updates
throughout&lt;/em&gt; &lt;a href=&quot;https://twitter.com/#!/search/%23rbxday&quot;&gt;#rbxday&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The first ever&lt;/strong&gt; &lt;a href=&quot;https://twitter.com/#!/search/%23rbxday&quot;&gt;#rbxday&lt;/a&gt; is fast
approaching on Friday, August 5th. Depending on your time zone, that is either
tomorrow or the day after tomorrow. To help you get prepared, here are a few
updates.&lt;/p&gt;

&lt;p&gt;Originally, the idea for &lt;a href=&quot;https://twitter.com/#!/search/%23rbxday&quot;&gt;#rbxday&lt;/a&gt;
was a day that people all around the world could have fun experimenting with
Ruby and Rubinius. Try your application or pet Ruby project on Rubinius, or
pull out that idea you've been wanting to explore, code it up, and run it on
Rubinius. We are not asking anyone to contribute to Rubinius, but we would be
most flattered if you wanted to dig into the Rubinius code to see what's going
on under the hood. To sum up, the motto of the day is &quot;Ruby, Rubinius, Fun Fun Fun Fun&quot;.&lt;/p&gt;

&lt;p&gt;Of course, a great way to multiply fun is to share it with others. Several
people have taken the initiative of organizing meetups on
&lt;a href=&quot;https://twitter.com/#!/search/%23rbxday&quot;&gt;#rbxday&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;San Francisco, CA, USA&lt;/strong&gt;: &lt;a href=&quot;http://twitter.com/engineyard&quot;&gt;Melissa Sheehan - @engineyard&lt;/a&gt;
of &lt;a href=&quot;http://engineyard.com&quot;&gt;Engine Yard&lt;/a&gt;, sign up at &lt;a href=&quot;http://rbxdaysf.eventbrite.com/&quot;&gt;rbxdaysf.eventbrite.com&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Mountain View, CA, USA&lt;/strong&gt;: &lt;a href=&quot;http://twitter.com/bcurren&quot;&gt;Ben Curren - @bcurren&lt;/a&gt; co-founder
of &lt;a href=&quot;http://outright.com&quot;&gt;Outright.com&lt;/a&gt;,
sign up at &lt;a href=&quot;http://rbxday.eventbrite.com/&quot;&gt;rbxday.eventbrite.com&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Los Angeles, CA, USA&lt;/strong&gt;: &lt;a href=&quot;http://twitter.com/veganstraightedge&quot;&gt;Shane Becker - @veganstraightedge&lt;/a&gt;
Open Source Cheerleader at &lt;a href=&quot;http://engineyard.com&quot;&gt;Engine Yard&lt;/a&gt;
for &lt;a href=&quot;http://rubini.us&quot;&gt;Rubinius&lt;/a&gt;, 10am - 8pm at
&lt;a href=&quot;http://farmhouse.la&quot;&gt;the Farmhouse&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Portland, OR, USA&lt;/strong&gt;: &lt;a href=&quot;http://twitter.com/kyledrake&quot;&gt;Kyle Drake - @kyledrake&lt;/a&gt;
avid Rubyist, event at &lt;a href=&quot;http://piepdx.com&quot;&gt;PIE&lt;/a&gt;, see
&lt;a href=&quot;http://calagator.org/events/1250461183&quot;&gt;Calagator.org&lt;/a&gt; for details&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Amsterdam, Netherlands&lt;/strong&gt;: &lt;a href=&quot;http://twitter.com/dbussink&quot;&gt;Dirkjan Bussink - @dbussink&lt;/a&gt;
long time Rubinius contributor, event at
&lt;a href=&quot;http://80beans.com/en/blog/2011/07/29/rbxday-at-the-80beans-office&quot;&gt;80beans&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Barcelona, Spain&lt;/strong&gt;: &lt;a href=&quot;http://twitter.com/txustice&quot;&gt;Josep M. Bach - @txustice&lt;/a&gt; inventor of
&lt;a href=&quot;http://blog.txustice.me/2011/06/rexpl-interactive-bytecode-console-for-rubinius&quot;&gt;cool Rubinius technology&lt;/a&gt;,
event at &lt;a href=&quot;http://blog.codegram.com/2011/8/celebrate-rbxday-with-us-at-codegram&quot;&gt;Codegram&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Montevideo, Uruguay&lt;/strong&gt;: &lt;a href=&quot;http://twitter.com/spastorino&quot;&gt;Santiago Pastorino - @spastorino&lt;/a&gt;
co-founder of &lt;a href=&quot;http://twitter.com/wyeworks&quot;&gt;@wyeworks&lt;/a&gt;, event at the &lt;a href=&quot;http://www.wyeworks.com/&quot;&gt;WyeWorks office&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;A huge thanks to everyone who has organized one of these events. They did so
on their own initiative and show the true power of a community. If you're near
one of the events, please do attend. If not, &lt;em&gt;there's still time to organize
one near you.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;If you are joining &lt;a href=&quot;http://twitter.com/#!/search/%23rbxday&quot;&gt;#rbxday&lt;/a&gt; from the
comfort of your own home, tweet about it, include pictures, and join us in
the &lt;a href=&quot;irc://irc.freenode.net#rubinius&quot;&gt;#rubinius&lt;/a&gt; IRC channel on freenode.net.
We would love to hear from you.&lt;/p&gt;

&lt;p&gt;A final thought about all the ways you can help Rubinius. You don't have to
contribute code directly to help. Each of these activities is just as
valuable, and if you think of any I didn't include, please let me know:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Wearing your &lt;a href=&quot;http://rubini.us/2011/05/26/rubinius-rewards&quot;&gt;Rubinius shirt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Talking to co-workers about Rubinius&lt;/li&gt;
&lt;li&gt;Asking your company to sponsor some of your time contributing to Rubinius&lt;/li&gt;
&lt;li&gt;Writing libraries in Ruby&lt;/li&gt;
&lt;li&gt;Writing blog posts or books about Ruby technology, like fully-concurrent
threads in &lt;a href=&quot;http://jruby.org&quot;&gt;JRuby&lt;/a&gt; and Rubinius 2.0&lt;/li&gt;
&lt;li&gt;Talking to people about what you find painful in Ruby and how we may be able
to improve those pain points&lt;/li&gt;
&lt;li&gt;Testing your code on Rubinius and submitting bug/performance reports&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Above all, please do have fun. That's no gimmick. The world needs more fun.&lt;/p&gt;

&lt;p&gt;Put a tag on it &lt;a href=&quot;http://twitter.com/#!/search/%23rbxday&quot;&gt;#rbxday&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Come hack in Amsterdam for &amp;#35;rbxday</title>
    <id>http://rubini.us/2011/07/31/rbxday-at-80beans/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2011/07/31/rbxday-at-80beans/" />
    <updated>2011-07-31T00:00:00-05:00</updated>
    <author>
      <name>Dirkjan Bussink</name>
    </author>
    
    <content type="html">&lt;p&gt;Not only in the US is &lt;a href=&quot;http://rbxday.rubini.us/&quot;&gt;&amp;#35;rbxday&lt;/a&gt; celebrated, but
we have also something in Amsterdam next Friday. It's really becoming the
International Rubinius Day that it was set out to be.&lt;/p&gt;

&lt;p&gt;The guys are &lt;a href=&quot;http://www.80beans.com/&quot;&gt;80beans&lt;/a&gt; are sponsoring the event and
have graciously offered their office as the place to hang out and are
providing refreshments. The office is located on the &lt;a href=&quot;http://maps.google.com/maps/place?q=80beans,+Amsterdam,+The+Netherlands&amp;amp;hl=en&amp;amp;cid=15251096961071716406&quot;&gt;Vijzelstraat 72&lt;/a&gt; in
Amsterdam and we're starting at 3pm.&lt;/p&gt;

&lt;p&gt;If you're living in the neighborhood, please come and join us. As long
term Rubinius contributor Dirkjan Bussink is coming over from the other side of
the country, so don't feel held back when you're not living in Amsterdam
itself.&lt;/p&gt;

&lt;p&gt;So be prepared for an afternoon of very interesting hacking. We really want
to make it a fun afternoon of experimenting with Rubinius, so anything
goes! Please leave a message on the &lt;a href=&quot;http://www.80beans.com/en/blog&quot;&gt;80beans blog&lt;/a&gt; if you're planning to come over:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.80beans.com/en/blog/2011/07/29/rbxday-at-the-80beans-office&quot;&gt;http://www.80beans.com/en/blog/2011/07/29/rbxday-at-the-80beans-office&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Hopefully see you there!&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Outright Hacks &amp;#35;rbxday</title>
    <id>http://rubini.us/2011/07/29/rbxday-at-outright/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2011/07/29/rbxday-at-outright/" />
    <updated>2011-07-29T00:00:00-05:00</updated>
    <author>
      <name>Brian Ford</name>
    </author>
    
    <content type="html">&lt;p&gt;Hey Ruby bytecode fans! The first ever &lt;strong&gt;International Rubinius Day&lt;/strong&gt; is next
Friday, August 5th. Around the world people will be trying their code on
Rubinius and generally having a fun time. Follow the activities on Twitter
under the &lt;em&gt;#rbxday&lt;/em&gt; tag and use that to let folks know what you're up to. Stay
tuned to the &lt;a href=&quot;http://rbxday.rubini.us/&quot;&gt;rbxday website&lt;/a&gt; for details as the day
unfolds.&lt;/p&gt;

&lt;p&gt;If you are located in, around, or within traveling distance of beautiful
Mountain View, CA, the terrific folks at &lt;a href=&quot;http://outright.com&quot;&gt;Outright.com&lt;/a&gt;
are sponsoring a real live &lt;em&gt;#rbxday&lt;/em&gt; event! Come hang out with a bunch of
hardcore Ruby nerds, including Brian Ford (that's me) from the Rubinius team.
Plan to be inspired by all the great stuff people are working on. There will
be mountains of top-shelf Rubinius schwag, as well as &lt;em&gt;free beer and pizza&lt;/em&gt;.
(Just don't get too trashed as there will also be lightning talks and an IR
helicopter obstacle course.)&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;http://rbxday.eventbrite.com/&quot;&gt;party&lt;/a&gt; will be from 1:00 pm to 8:00 pm on
Friday August 5th at Outright's offices in downtown Mountain View. (They have
an application that does some seriously awesome stuff with small business
accounting.) There are plenty of desks, monitors and whiteboards available, so
bring your laptop and be ready to jam.&lt;/p&gt;

&lt;p&gt;Space is limited, and the coolest developers in the valley are already coming,
so if you know your stuff and want to have fun, &lt;a href=&quot;http://rbxday.eventbrite.com/&quot;&gt;rsvp
now&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;See you there!&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">rbxday</title>
    <id>http://rubini.us/2011/07/07/rbxday/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2011/07/07/rbxday/" />
    <updated>2011-07-07T00:00:00-05:00</updated>
    <author>
      <name>Shane Becker</name>
    </author>
    
    <content type="html">&lt;h3&gt;We&amp;rsquo;re having a party and you&amp;rsquo;re invited!&lt;/h3&gt;

&lt;h3&gt;&lt;a href=&quot;http://rbxday.rubini.us&quot;&gt;rbxday.rubini.us&lt;/a&gt;&lt;/h3&gt;

&lt;h4&gt;Friday, August 5, 2011 is &lt;a href=&quot;http://rbxday.rubini.us&quot;&gt;#rbxday&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;The Rubinius 2.0 Preview Release is still cranking along. We&amp;rsquo;re feeling good about how things are going. As always, thank you everyone for all of your contributions. The &lt;a href=&quot;http://rubini.us/releases/1.2.4/#authors&quot; title=&quot;Rubinius : Use Ruby&amp;#8482;&quot;&gt;list of authors on the 1.2.4 release&lt;/a&gt; is just fantastic.&lt;/p&gt;

&lt;p&gt;Moving forward to the 2.0 official release, we need more feedback from you about your code running on Rubinius. Not just what doesn&amp;rsquo;t work and not just bugs (although both of those are important too), but how is your code performing, where are the bottlenecks, etc.&lt;/p&gt;

&lt;p&gt;This is what we&amp;rsquo;re going to do about that. Everyone... everyone all around the world that uses or cares about Rubinius and its progress, all of us on one day are going to run our code, collect performance data / bug reports and send them up to the Rubinius project.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://twitter.com/#!/search/%23rbxday&quot;&gt;#rbxday&lt;/a&gt; is a party! Take pictures of you and your buddies on the day of. If you&amp;rsquo;ve got a Rubinius t-shirt or sticker, get them in there. Tweet about it, now and on the day. Get excited. Tell your friends. Get them excited. Use the hashtag #rbxday in your tweets, blog posts and posts. We&amp;rsquo;ll repost them all on the &lt;a href=&quot;http://rbxday.rubini.us&quot;&gt;#rbxday&lt;/a&gt; site.&lt;/p&gt;

&lt;p&gt;Make sure you&amp;rsquo;re looking your best in your photos because we&amp;rsquo;ll be picking a winner for our favorite &lt;a href=&quot;http://twitter.com/#!/search/%23rbxday&quot; title=&quot;#rbxday search on Twitter&quot;&gt;#rbxday&lt;/a&gt; glamourshot. Tweet them using the hashtag &lt;a href=&quot;http://twitter.com/#!/search/%23rbxday&quot; title=&quot;#rbxday search on Twitter&quot;&gt;#rbxday&lt;/a&gt; and we&amp;rsquo;ll announce the winning photo Monday, August 8, 2011 on the &lt;a href=&quot;http://facebook.com/engineyard&quot;&gt;Engine Yard Facebook page&lt;/a&gt;. We&amp;rsquo;ll have a nifty prize for the winner too, so make sure your pic is goofy, sultry, or otherwise impressive. Bonus points for creativity.&lt;/p&gt;

&lt;p&gt;Get your party hats on!&lt;/p&gt;

&lt;p&gt;&amp;mdash;XOXO RBX&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">What&amp;rsquo;s the Status, Kenneth?</title>
    <id>http://rubini.us/2011/07/05/whats-the-status-kenneth/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2011/07/05/whats-the-status-kenneth/" />
    <updated>2011-07-05T00:00:00-05:00</updated>
    <author>
      <name>Shane Becker</name>
    </author>
    
    <content type="html">&lt;p&gt;I&amp;rsquo;m pretty sure it started like this.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;&amp;ldquo;Hello, Evan dear.&amp;rdquo; &amp;mdash; &lt;em&gt;Evan&amp;rsquo;s Grandma Betty&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Grandma Betty!&amp;rdquo; &amp;mdash; &lt;em&gt;Evan&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;You know, I was thinking about your little Rubinius thingy while I was gardening today. How&amp;rsquo;s it doing?&amp;rdquo; &amp;mdash; &lt;em&gt;Evan&amp;rsquo;s Grandma Betty&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Oh, Grandma Betty, that&amp;rsquo;s so sweet of you to think of me and it. It&amp;rsquo;s coming along still, of course.&amp;rdquo; &amp;mdash; &lt;em&gt;Evan&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;That&amp;rsquo;s good to hear. I was specifically wondering how the 1.9 support is looking.&amp;rdquo; &amp;mdash; &lt;em&gt;Evan&amp;rsquo;s Grandma Betty&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Grandma Betty! You do always love the Latest and Greatest&amp;trade;, don&amp;rsquo;t you? Well, let&amp;rsquo;s see. I&amp;rsquo;d say that &lt;em&gt;1.9 support&lt;/em&gt; comes down to 7 main areas: Encoding, String, Regex, Symbol, IO, Argument Processing, Windows Support. Each has varying degrees of progress.&amp;rdquo; &amp;mdash; &lt;em&gt;Evan&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;OK. I wish that there was some way for me to keep more up to date on these happenings without needing to calling you. When I call you, I want to hear about that wife and baby of yours.&amp;rdquo; &amp;mdash; &lt;em&gt;Evan&amp;rsquo;s Grandma Betty&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;You got it, Grandma Betty. I&amp;rsquo;ll get my Top Nerds&amp;trade; on the case.&amp;rdquo; &amp;mdash; &lt;em&gt;Evan&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;[sometime later]&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Alright, Grandma Betty. We made the Rubinius Status Board&amp;trade; especially just for you. It&amp;rsquo;s &lt;a href=&quot;http://status.rubini.us&quot;&gt;status.rubini.us&lt;/a&gt;&amp;rdquo; &amp;mdash; &lt;em&gt;Evan&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That conversation may or may not be &lt;strong&gt;completely fictionalized&lt;/strong&gt;. There is one thing that is most emphatically true: Rubinius has a Status Board&amp;trade; now. If you are ever curious how progress is going on things, go check out &lt;a href=&quot;http://status.rubini.us&quot;&gt;status.rubini.us&lt;/a&gt;. Tell your friends.&lt;/p&gt;

&lt;p&gt;XOXO RBX.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Rubinius All Around the World</title>
    <id>http://rubini.us/2011/07/03/all-around-the-world/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2011/07/03/all-around-the-world/" />
    <updated>2011-07-03T00:00:00-05:00</updated>
    <author>
      <name>Shane Becker</name>
    </author>
    
    <content type="html">&lt;p&gt;As a result of the &lt;a href=&quot;http://rubini.us/2011/05/26/rubinius-rewards/&quot; title=&quot;Announcing Rubinius Rewards - Rubinius&quot;&gt;Rubinius Rewards&lt;/a&gt;, people from all over the world have requested Rubinius stickers and t-shirts. That just warms our little hearts and humbles us everyday. Thank you so much. It means the world to us. Keep using Rubinius with passion and excitement. Keep spreading the good word to your friends and anyone who'll listen and care. And keep telling us how Rubinius is working for you. However good or bad, we want to know.&lt;/p&gt;

&lt;p&gt;Here's a map of all the places where we've sent stickers and/or t-shirts. You can also view it on
&lt;a href=&quot;http://maps.google.com/maps/ms?msa=0&amp;amp;amp;msid=204706765448868864026.0004a732bcb9b5816e407&amp;amp;amp;ie=UTF8&amp;amp;amp;ll=19.311143,-0.351562&amp;amp;amp;spn=111.602296,333.632812&amp;amp;amp;z=2&amp;amp;amp;source=embed&quot; title=&quot;Rubinius Around the World - Google Maps&quot;&gt;a larger map&lt;/a&gt;. Wow.&lt;/p&gt;

&lt;iframe width=&quot;950&quot; height=&quot;400&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; marginheight=&quot;0&quot; marginwidth=&quot;0&quot; src=&quot;http://maps.google.com/maps/ms?msa=0&amp;amp;msid=204706765448868864026.0004a732bcb9b5816e407&amp;amp;ie=UTF8&amp;amp;ll=19.311143,-0.351562&amp;amp;spn=111.602296,333.632812&amp;amp;z=2&amp;amp;output=embed&quot;&gt;&lt;/iframe&gt;


&lt;p&gt;Again, thank you from the bottom of our hearts.&lt;/p&gt;

&lt;p&gt;Stay safe, kids.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;XOXO RBX&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Rubinius Summit 062011 in Pictures</title>
    <id>http://rubini.us/2011/07/01/rubinius-summit-in-pictures/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2011/07/01/rubinius-summit-in-pictures/" />
    <updated>2011-07-01T00:00:00-05:00</updated>
    <author>
      <name>Shane Becker</name>
    </author>
    
    <content type="html">&lt;p&gt;Once a month Evan Phoenix, Brian Ford and I (Shane Beccker) get together for a few days in-person face-time. Usually we meet up in San Francisco at the &lt;a href=&quot;http://engineyard.com&quot;&gt;Engine Yard&lt;/a&gt; HQ and spend time with our dear and lovely boss, &lt;a href=&quot;http://twitter.com/drnic&quot;&gt;Dr Nic&lt;/a&gt;. We like to call these little get togethers Rubinius Summits. For the June 2011 Rubinius Summit, Brian came down to LA where both Evan and I live. We spent the week working together at &lt;a href=&quot;http://farmhouse.la&quot;&gt;The Farmhouse&lt;/a&gt; on moving the ball forward toward the 2.0 release. Here's a few pictures of some of the things that went down.&lt;/p&gt;

&lt;h3&gt;I Used Rubinius at RailsConf 2011 stickers&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://flickr.com/photos/veganstraightedge/5885836117&quot;&gt;&lt;img src=&quot;http://farm7.static.flickr.com/6052/5885836117_ba60ba6408_z.jpg&quot; title=&quot;&amp;quot;I Used Rubinius at RailsConf 2011&amp;quot; stickers at The Farmhouse in Hollywood, CA                     &quot; alt=&quot;&amp;quot;I Used Rubinius at RailsConf 2011&amp;quot; stickers at The Farmhouse in Hollywood, CA&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;These stickers arrived and are ready to be shipped out. If you DMed your address to &lt;a href=&quot;http://twitter.com/rubinius&quot;&gt;us on Twitter&lt;/a&gt;, we've got you. If you never contacted us, but used Rubinius while at RailsConf 2011 in Baltimore, email us at &lt;a href=&quot;mailto:community@rubini.us&quot;&gt;community@rubini.us&lt;/a&gt; to get your sticker.&lt;/p&gt;

&lt;h3&gt;T-Shirts!&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://flickr.com/photos/veganstraightedge/5889084175&quot;&gt;&lt;img src=&quot;http://farm7.static.flickr.com/6019/5889084175_6414a83e97_z.jpg&quot; title=&quot;Nearly 600 more @Rubinius shirts just arrived at the @farmhouse in Hollywood, CA                             &quot; alt=&quot;Nearly 600 more @Rubinius shirts just arrived at the @farmhouse in Hollywood, CA&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is what nearly 600 shirts looks like. We've got a huge back log of people all over the world who responded to our offer of free Rubinius t-shirts. Those will all get shipped out over the next week or so.&lt;/p&gt;

&lt;h3&gt;Progress on 1.9 Support&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://flickr.com/photos/veganstraightedge/5888809669&quot;&gt;&lt;img src=&quot;http://farm6.static.flickr.com/5076/5888809669_134b0d6e23_z.jpg&quot; title=&quot;Serious @rubinius big brain nerdery happening between @brixen and @evanphx at the @farmhouse in Hollywood, CA&quot; alt=&quot;Serious @rubinius big brain nerdery happening between @brixen and @evanphx at the @farmhouse in Hollywood, CA&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Brian and Evan, like a couple of mad scientists, sketched out how to handle 1.9 block arguments for Rubinus 2.0.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://flickr.com/photos/veganstraightedge/5889687428&quot;&gt;&lt;img src=&quot;http://farm6.static.flickr.com/5038/5889687428_b2f0f07f40_z.jpg&quot; title=&quot;A sketch of Ruby 1.9 block args in Rubinus 2.0 by @evanphx and @brixen at the @farmhouse in Hollywood, CA    &quot; alt=&quot;A sketch of Ruby 1.9 block args in Rubinus 2.0 by @evanphx and @brixen at the @farmhouse in Hollywood, CA&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://flickr.com/photos/veganstraightedge/5889686740&quot;&gt;&lt;img src=&quot;http://farm7.static.flickr.com/6024/5889686740_ca7962db63_z.jpg&quot; title=&quot;A sketch of Ruby 1.9 block args in Rubinus 2.0 by @evanphx and @brixen at the @farmhouse in Hollywood, CA    &quot; alt=&quot;A sketch of Ruby 1.9 block args in Rubinus 2.0 by @evanphx and @brixen at the @farmhouse in Hollywood, CA&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here are the sketches of 1.9 block arguments for Rubinus 2.0.&lt;/p&gt;

&lt;h3&gt;One More Thing&lt;/h3&gt;

&lt;p&gt;We came up with an idea this week for how to better communicate outwardly and be more transparent. We built it up real quick and are launching it ...&lt;em&gt;really soon&lt;/em&gt;. Here's a little teaser.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://drbl.in/bxbg&quot;&gt;&lt;img src=&quot;http://dribbble.com/system/users/1288/screenshots/202858/rubinius_...thing_2.png&quot; title=&quot;Rubinius teaser 1&quot; alt=&quot;Rubinius teaser 1&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;http://drbl.in/bxbf&quot;&gt;&lt;img src=&quot;http://dribbble.com/system/users/1288/screenshots/202857/rubinius_...thing_1.png&quot; title=&quot;Rubinius teaser 2&quot; alt=&quot;Rubinius teaser 2&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;XOXO RBX&lt;/em&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Inside the Rubinius 2.0 Preview Release</title>
    <id>http://rubini.us/2011/06/07/inside-rubinius-20-preview/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2011/06/07/inside-rubinius-20-preview/" />
    <updated>2011-06-07T00:00:00-05:00</updated>
    <author>
      <name>Brian Ford</name>
    </author>
    
    <content type="html">&lt;p&gt;Houston, we have a problem. Complex projects are difficult to transition
forward and Rubinius is a complex project. Rubinius is at the point of a major
transition and we need your help to move forward.&lt;/p&gt;

&lt;p&gt;Just over a year ago, Rubinius released version 1.0. Since then, dozens of
contributors have added over 2,200 commits to the master branch and we have
released seven new versions. At the same time, we have added nearly 450
commits on a development branch to remove the global interpreter lock (GIL)
and begin adding Ruby 1.9 and Windows support.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/rubinius-2-0-developer-preview-blog-post.png&quot; alt=&quot;Rubinius 2.0 Developer Preview&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Today we are releasing &lt;em&gt;Rubinius 2.0 Developer Preview&lt;/em&gt;. The primary focus of
this release is true Ruby multi-threaded concurrency. Additionally, it
contains the beginnings of Ruby 1.9 and Microsoft Windows support.&lt;/p&gt;

&lt;h3&gt;Rubinius 2.0 Developer Preview&lt;/h3&gt;

&lt;p&gt;We are seeking developers interested in running their Ruby and Rails projects
on Rubinius to help us iron out issues as we work toward the final 2.0
release. Let's look at the details of the 2.0 developer preview.&lt;/p&gt;

&lt;p&gt;One of the central features of Rubinius 2.0 is a fundamental change in the
threading architecture. In Rubinius 2.0, Ruby threads will run with true
concurrency. This means that if multi-core or multi-CPU hardware is available,
Ruby code on different threads will actually run in parallel.&lt;/p&gt;

&lt;p&gt;Another central feature of Rubinius 2.0 is support for both Ruby 1.8.7 and
Ruby 1.9.2 syntax. The Rubinius 2.0 support for Ruby 1.8.7 should be 100%
backward compatible with the support in the Rubinius master branch. The full
Ruby concurrency is enabled regardless of what language syntax mode is active.&lt;/p&gt;

&lt;h3&gt;Repository Migration&lt;/h3&gt;

&lt;p&gt;We are migrating the main Rubinius repository to the &lt;a href=&quot;https://github.com/rubinius&quot;&gt;Rubinius&lt;/a&gt; organization.&lt;/p&gt;

&lt;p&gt;The RVM project has already been updated to work with the new repository. So
&lt;code&gt;rvm install rbx&lt;/code&gt; will use the new repository.  If you have an existing clone
of Rubinius, update and run &lt;code&gt;rake github&lt;/code&gt; to point your existing repository to
the new one.&lt;/p&gt;

&lt;p&gt;You can clone directly from the &lt;a href=&quot;https://github.com/rubinius/rubinius&quot;&gt;new repository&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Installation&lt;/h3&gt;

&lt;p&gt;For testing Rubinius with your application, installing with RVM is probably
the easiest. To install the 2.0 developer preview, ensure that RVM is updated:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rvm get head
rvm reload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, install the Rubinius 2.0.0pre branch:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rvm install rbx-2.0.0pre
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you are interested in helping develop Rubinius, we suggest you clone the
repository directly and build. Rubinius runs fine from the source directory so
you don't need to install it. For more details about building from a clone,
see &lt;a href=&quot;http://rubini.us/doc/en/getting-started/&quot;&gt;Getting Started&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Configuration&lt;/h3&gt;

&lt;p&gt;The goal of Rubinius 2.0 is to fully support both Ruby 1.8.7 and 1.9.2 in a
single executable. When running Rubinius, you can select which version to use.
There are configuration options to change which versions are supported and
which version is the default.&lt;/p&gt;

&lt;p&gt;The first configure option is &lt;code&gt;--enable-version=X[,Y]&lt;/code&gt;. This option sets which
language versions will be supported. An example is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./configure --enable-version=1.8,1.9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The language versions can be specified as &lt;code&gt;18&lt;/code&gt; or &lt;code&gt;1.8&lt;/code&gt;. Multiple versions are
separated by a comma and no space.&lt;/p&gt;

&lt;p&gt;The second configure option is &lt;code&gt;--default-version=X&lt;/code&gt;. This option sets which
language version is the default when running Rubinius. An example is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./configure --default-version=1.9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These options are intended to be used together. You must enable a version to
select it as the default, so the options must come in the following order:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./configure --enable-version=X,Y --default-version=Y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you have enabled support for a language version, to select that mode when
running Rubinius, use the &lt;code&gt;-X18&lt;/code&gt; or &lt;code&gt;-X19&lt;/code&gt; command line switches. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rbx -X19 -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command will run Rubinius with the 1.9 language mode enabled.&lt;/p&gt;

&lt;p&gt;You may also use the &lt;code&gt;RBXOPT&lt;/code&gt; environment variable to select the language
mode. Assuming that 1.8 is the default mode, the following command would run
Rubinius with the 1.9 language mode enabled:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RBXOPT=-X19 rbx -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Right now, only the 1.8 language mode is enabled in the 2.0.0pre branch.
However, we will be enabling the 1.9 mode in the very near future. The default
mode will continue to be 1.8 unless you configure Rubinius to run in 1.9 mode.&lt;/p&gt;

&lt;h3&gt;Building on Windows&lt;/h3&gt;

&lt;p&gt;On Windows, Rubinius uses the &lt;a href=&quot;http://mingw-w64.sourceforge.net/&quot;&gt;MinGW-w64&lt;/a&gt;
compiler to build a native application. There remains a lot of work to do for
Windows support but the Rubinius VM is currently compiling on Windows 7.&lt;/p&gt;

&lt;p&gt;If you are a bleeding-edge Windows developer interested in diving into
Rubinius, here's how to get started:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Install &lt;em&gt;MRI 1.9&lt;/em&gt; using &lt;a href=&quot;http://rubyinstaller.org/&quot;&gt;RubyInstaller&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Install &lt;a href=&quot;http://code.google.com/p/msysgit/&quot;&gt;MSysGit&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Install the 32bit or 64bit MinGW-w64 toolchain.&lt;/li&gt;
&lt;li&gt;Clone the Rubinius repository.&lt;/li&gt;
&lt;li&gt;In CMD, run &lt;code&gt;ruby configure&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;rake&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;Moving Forward&lt;/h3&gt;

&lt;p&gt;In the near future, we will release another version of Rubinius from the
current master branch. We hope to merge 2.0.0pre into master as soon as
possible and continue working toward the 2.0 final release. We'll make that
decision based on your reports about how the 2.0.0pre branch is working with
existing 1.8.7 applications.&lt;/p&gt;

&lt;p&gt;We greatly appreciate your help polishing up the Rubinius 2.0 release! Follow
us on &lt;a href=&quot;http://twitter.com/rubinius&quot;&gt;Twitter&lt;/a&gt; for updates and stop by #rubinius
on freenode.net to chat about anything on your mind.&lt;/p&gt;

&lt;h3&gt;Rubinius Support on EngineYard AppCloud&lt;/h3&gt;

&lt;p&gt;Rubinius 1.2.3 is currently in beta on Engine Yard AppCloud, and we encourage
users to &lt;a href=&quot;http://docs.engineyard.com/rubinius.html&quot;&gt;give it a try&lt;/a&gt;. Engine
Yard will support Rubinius 2.0.0 after its officially released.&lt;/p&gt;

&lt;p&gt;To learn more about Rubinius, join Engine Yard for a &lt;a href=&quot;http://pages.engineyard.com/RubyPlatformOptionsWebinarJuly212011.html&quot;&gt;Platform Options Webinar&lt;/a&gt; in July.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Announcing Rubinius Rewards</title>
    <id>http://rubini.us/2011/05/26/rubinius-rewards/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2011/05/26/rubinius-rewards/" />
    <updated>2011-05-26T00:00:00-05:00</updated>
    <author>
      <name>Shane Becker</name>
    </author>
    
    <content type="html">&lt;h3&gt;Update&lt;/h3&gt;

&lt;p&gt;See &lt;a href=&quot;http://rubini.us/2011/09/02/retiring-some-rubinius-rewards/&quot; title=&quot;Retiring (Some) Rubinius Rewards - Rubinius&quot;&gt;this post&lt;/a&gt; about retired shirts/stickers and to see what's still available.&lt;/p&gt;

&lt;h2&gt;tl;dr&lt;/h2&gt;

&lt;p&gt;Email &lt;a href=&quot;mailto:community@rubini.us&quot;&gt;community@rubini.us&lt;/a&gt; to get stickers and
t-shirts. Include your mailing address.&lt;/p&gt;

&lt;h2&gt;We Made T-Shirts and Stickers&lt;/h2&gt;

&lt;p&gt;We heard you like stickers and t-shirts, so we made some. They
debuted at &lt;a href=&quot;http://en.oreilly.com/rails2011&quot; title=&quot;RailsConf 2011 - O'Reilly Conferences, May 16 - 19, 2011, Baltimore, MD!&quot;&gt;RailsConf 2011 in Baltimore, MD&lt;/a&gt;.
Then we gave almost all of them away in just a few hours. They went like
hotcakes. It turns out that there was a lot of pent up demand for Rubinius
swag.&lt;/p&gt;

&lt;p&gt;Not everyone could be at RailsConf to get the goods, of course. Even some
people who were there didn't get their shirts/stickers. If you didn't get one
and want one, we're very sorry, but don't you worry. We've got you covered.&lt;/p&gt;

&lt;h2&gt;General Availability Stickers&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.flickr.com/photos/veganstraightedge/5742057726&quot;&gt;&lt;img src=&quot;http://farm3.static.flickr.com/2458/5742057726_48c42d5462_z.jpg&quot; title=&quot;A box of Rubinius stickers by veganstraightedge, on Flickr&quot; alt=&quot;A box of Rubinius stickers&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We've got a box of stickers in three designs:
&lt;a href=&quot;http://asset.rubini.us/web/images/blog/rubinius_square_sticker.png&quot;&gt;square&lt;/a&gt;,
&lt;a href=&quot;http://asset.rubini.us/web/images/blog/rubinius_bumper_sticker.png&quot;&gt;bumper&lt;/a&gt;
and
&lt;a href=&quot;http://asset.rubini.us/web/images/blog/rubinius_diecut_sticker.png&quot;&gt;die-cut&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;mailto:community@rubini.us&quot;&gt;Email us&lt;/a&gt; and tell us which one you want.&lt;/p&gt;

&lt;h2&gt;General Availability T-Shirt&lt;/h2&gt;

&lt;p&gt;We're printing 500 more grey Rubinius t-shirts in the two different designs
and in a a handful of sizes (women's small and medium, unisex small &amp;ndash;
xx-large).&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;mailto:community@rubini.us&quot;&gt;Email us&lt;/a&gt; and tell us which design / size you want:
&lt;a href=&quot;http://asset.rubini.us/web/images/blog/rubinius_use_ruby_square_shirt.jpg&quot;&gt;square&lt;/a&gt;
or
&lt;a href=&quot;http://asset.rubini.us/web/images/blog/rubinius_use_ruby_horizontal_shirt.jpg&quot;&gt;horizontal&lt;/a&gt;
in
women's small, women's medium, unisex small, unisex medium, unisex large,
unisex x-large or unisex xx-large.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.flickr.com/photos/veganstraightedge/5709097384&quot;&gt;&lt;img src=&quot;http://farm4.static.flickr.com/3469/5709097384_0bde99e1d3_z.jpg&quot; title=&quot;Rubinius &amp;quot;Use Ruby&amp;trade;&amp;quot; T-Shirts at the Farmhouse in Hollywood, CA, on Flickr&quot; alt=&quot;Rubinius &amp;quot;Use Ruby&amp;trade;&amp;quot; T-Shirts at the Farmhouse in Hollywood, CA&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Photo by &lt;a href=&quot;http://flickr.com/tjnelsonjunior&quot; title=&quot;Flickr: tjnelsonjunior's Photostream&quot;&gt;Tj Nelson Jr&lt;/a&gt;
&lt;a href=&quot;http://twitter.com/tjnelsonjr&quot; title=&quot;@tjnelsonjr&quot;&gt;@tjnelsonjr&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;First Commit Sticker&lt;/h2&gt;

&lt;p&gt;Going forward, we want to reward everyone who makes a contribution to
Rubinius. As a very small token of our gratitude, we're mailing a Rubinius
sticker (and a handwritten thank you note from one of us) to everyone after
their first commit. So, if you've ever thought about dipping your toe into
Rubinius (or diving headlong into the deep end), now's the best time ever.
Help us make Rubinius better (in big and small ways) and we'll send you stuff.&lt;/p&gt;

&lt;h2&gt;Tenth Commit Shirt&lt;/h2&gt;

&lt;p&gt;We want you to stick around and keep helping Rubinius to get better and better.
If you make 10 commits to Rubinius, we'll send you a special shirt only
available to committers. That design is still a secret for now, but it's just
for 10+ committers.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Please, don't try to game the system by intentionally breaking stuff up into
smaller commits just to bump up your count. Let's keep it honest.&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;Quarterly Committer Merit Badge Stickers&lt;/h2&gt;

&lt;p&gt;In addition to getting a generally available sticker after your first commit,
at the end of each calendar quarter (every three months) we're sending a
sticker to everyone who committed to Rubinius &lt;strong&gt;during&lt;/strong&gt; that quarter.&lt;/p&gt;

&lt;p&gt;E.g. after July 1, 2011, we'll print and ship a sticker to everyone who
committed between April 1 and June 30. Each quarter's sticker has the year /
quarter in the corner. Keep committing every quarter and you'll keep
collecting the merit badge stickers.&lt;/p&gt;

&lt;h2&gt;One More Thing &amp;mdash; I'm Committed* Sticker&lt;/h2&gt;

&lt;p&gt;Rubinius is obviously older than the new Rubinius Rewards program. To backfill
for all the contributions people have made over the years up until, we have a
&lt;em&gt;super duper limited edition never to be made again&lt;/em&gt; sticker... the asterisk.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.flickr.com/photos/veganstraightedge/5742135762&quot;&gt;&lt;img src=&quot;http://farm4.static.flickr.com/3187/5742135762_521146bdf9_z.jpg&quot; title=&quot;The new @Rubinius stickers on my @EngineYard laptop, on Flickr&quot; alt=&quot;Rubinius stickers on my laptop&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Get in Touch&lt;/h2&gt;

&lt;p&gt;If you're a past committer, &lt;a href=&quot;mailto:community@rubini.us&quot;&gt;email us&lt;/a&gt; your
mailing address get your special merit sticker. If you're a new committer,
we'll try to take note and reach out to you. If you don't hear from us,
don't be afraid to contact us with your mailing address.&lt;/p&gt;

&lt;h3&gt;Up Next...&lt;/h3&gt;

&lt;p&gt;Rubinius International Outposts.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Adam Prescott on Scopes in Rubinius</title>
    <id>http://rubini.us/2011/05/22/adam-prescott-on-scopes/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2011/05/22/adam-prescott-on-scopes/" />
    <updated>2011-05-22T00:00:00-05:00</updated>
    <author>
      <name>Shane Becker</name>
    </author>
    
    <content type="html">&lt;p&gt;&lt;cite class=&quot;vcard&quot;&gt;&lt;a class=&quot;url fn&quot; href=&quot;http://aprescott.com&quot; title=&quot;Adam Prescott&quot;&gt;Adam Prescott&lt;/a&gt;&lt;/cite&gt; wrote a lengthy article about &lt;i&gt;variables, closures and scope&lt;/i&gt; in Ruby, &lt;a href=&quot;http://aprescott.com/posts/variables-closures-and-scope&quot; title=&quot;Posts / Variables, closures &amp;amp; scope &amp;mdash; Adam Prescott&quot;&gt;mentioning Rubinius at the end&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote cite=&quot;http://aprescott.com/posts/variables-closures-and-scope&quot;&gt;
  &lt;p&gt; One of the really cool things about the &lt;a href=&quot;http://en.wikipedia.org/wiki/Rubinius&quot;&gt;Rubinius&lt;/a&gt; implementation of Ruby is that it exposes, by requirement, a level of internals which you can&amp;rsquo;t find in &lt;abbr title=&quot;Matz' Ruby Interpreter&quot;&gt;MRI&lt;/abbr&gt;, including some internals with scopes. Because these internals are exposed in Ruby itself, you can &lt;a href=&quot;http://yehudakatz.com/2011/02/18/getting-comfortable-with-rubinius-pure-ruby-internals/&quot;&gt;play around with scopes as objects&lt;/a&gt;, using &lt;code&gt;VariableScope&lt;/code&gt;, including getting access to the available local variables within that scope, with &lt;code&gt;VariableScope.current.locals&lt;/code&gt;. &lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt;How are &lt;strong&gt;you&lt;/strong&gt; using Rubinius? What are you doing with it that you couldn't do before? What is it missing for you to really dive in? Let us know. We're listening.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;community@rubini.us&quot;&gt;community@rubini.us&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://twitter.com/rubinius&quot; title=&quot;@rubinius on twitter&quot;&gt;@rubinius&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&amp;mdash; Use Ruby&amp;trade;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Rubinius T-Shirts and Stickers</title>
    <id>http://rubini.us/2011/04/29/rubinius-t-shirts-and-stickers/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2011/04/29/rubinius-t-shirts-and-stickers/" />
    <updated>2011-04-29T00:00:00-05:00</updated>
    <author>
      <name>Shane Becker</name>
    </author>
    
    <content type="html">&lt;h3&gt;Allow Myself to Introduce Myself&lt;/h3&gt;

&lt;p&gt;Hi. I'm Shane (&lt;a href=&quot;http://twitter.com/veganstraightedge&quot;&gt;@veganstraightedge&lt;/a&gt;
/ &lt;a href=&quot;http://iamshane.com&quot;&gt;iamshane.com&lt;/a&gt;). I'll be helping out around here now.
I was recently hired by &lt;a href=&quot;http://engineyard.com&quot;&gt;Engine Yard&lt;/a&gt; to be their Open
Source Cheerleader. (Yes, there will be costumes at some point.) My
primary focus is &lt;strong&gt;Rubinius! Rubinius! Rubinius!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I have lots of big plans for helping get Rubinius used by more people
in more places and how to have a better conversation with people who are using
it. For now though, I tell you about just the first thing that I've done.&lt;/p&gt;

&lt;h3&gt;T-Shirts&lt;/h3&gt;

&lt;h4&gt;The First Ever Rubinius T-Shirt from RailsConf 2007&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://asset.rubini.us/web/images/blog/rubinius_sword_shirt.jpg&quot; alt=&quot;The First Ever Rubinius T-Shirt from RailsConf 2007&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A long time ago (2007) in a city far, far away (Seattle, WA), Evan and I made
the first batch of Rubinius t-shirts. There were about two dozen made and
given to the handful of contributors at the time. This was at RailsConf in
Portland, OR. Since then there hasn't been &lt;em&gt;anything&lt;/em&gt; made with the Rubinius
logo on it.&lt;/p&gt;

&lt;p&gt;Now is the time to rectify that. We've made two different t-shirts. Same
messaging, slightly different design orientation. Both are the same colors:
white on asphalt. They are available in an assortment of sizes from women's
small to unisex xx-large.&lt;/p&gt;

&lt;h4&gt;Use Ruby Rubinius T-Shirts from RailsConf 2011&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://asset.rubini.us/web/images/blog/rubinius_use_ruby_square_shirt.jpg&quot; alt=&quot;Use Ruby Square Ruby T-Shirt from RailsConf 2011&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://asset.rubini.us/web/images/blog/rubinius_use_ruby_horizontal_shirt.jpg&quot; alt=&quot;Use Ruby Horizontal Ruby T-Shirt from RailsConf 2011&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If you're going to RailsConf 2011 in Baltimore, MD, stop by the Engine Yard booth
to pick up a free Rubinius t-shirt. After RailsConf we'll have ways to get one
from us directly.&lt;/p&gt;

&lt;h3&gt;Stickers&lt;/h3&gt;

&lt;p&gt;To go along with the t-shirts, we're making a whole grip of Rubinius stickers.
Most of which will also be available for free from the Engine Yard booth at
RailsConf in Baltimore. Again, after RailsConf you'll be able to get them
directly from us. More on that later. Here's what we have in store.&lt;/p&gt;

&lt;h4&gt;Wide Screen (7in x 3.75in)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://asset.rubini.us/web/images/blog/rubinius_bumper_sticker.png&quot; alt=&quot;Rubinius : Use Ruby bumper sticker&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;Square Logo&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://asset.rubini.us/web/images/blog/rubinius_square_sticker.png&quot; alt=&quot;Rubinius : Use Ruby square sticker&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;Die-Cut R Logo&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://asset.rubini.us/web/images/blog/rubinius_diecut_sticker.png&quot; alt=&quot;Rubinius : r logo diecut sticker&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;I'm Committed Merit Sticker&lt;/h4&gt;

&lt;p&gt;This one you have to earn. At the end of each quarter, we'll send out a little
one inch square sticker with a year/quarter combination in its corner to
everyone who committed something to Rubinius during that calendar quarter. For
all of the incredible folks who've contributed something (however big or small)
already, you'll get a special sticker. Instead of a date, there's an asterisk.
Only those of you that've committed so far will get that one.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://asset.rubini.us/web/images/blog/rubinius_alumni_sticker.png&quot; alt=&quot;Rubinius : I'm committed past committers sticker&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Come find us to get free Rubinius shirts and stickers. And stay tuned to
&lt;a href=&quot;http://rubini.us/blog&quot;&gt;the Rubinius blog&lt;/a&gt; and to the Twitter account :
&lt;a href=&quot;http://twitter.com/rubinius&quot;&gt;@rubinius&lt;/a&gt;. We have lots more in store.&lt;/p&gt;

&lt;p&gt;&amp;mdash; Use Ruby&amp;trade;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Running Ruby With No Ruby</title>
    <id>http://rubini.us/2011/03/17/running-ruby-with-no-ruby/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2011/03/17/running-ruby-with-no-ruby/" />
    <updated>2011-03-17T00:00:00-05:00</updated>
    <author>
      <name>Brian Ford</name>
    </author>
    
    <content type="html">&lt;p&gt;Humans have come a long way since our cave-dwelling days. No, that's not a
metaphor for primitive software. I mean literally since we lived in caves. One
of the big inventions is the lock. There are birds that bury food and will
move it later if they notice they were watched burying it. But they have no
access control. Any bird may come along and dig up the food.&lt;/p&gt;

&lt;p&gt;Humans, though, are smarter than the average bird.&lt;/p&gt;

&lt;p&gt;We have numerous systems that implement the analog of a lock, namely, some
sort of access control. For every one of these systems, we have other systems
that attempt to circumvent or defeat the access control. Two sides of the
ubiquitous coin of life.&lt;/p&gt;

&lt;p&gt;In software, attempts to implement access control typically involve
distinguishing between source code and some form of executable code. Direct
access to the source code is not permitted. Further, the format of the
executable code resists attempts to derive the source code. There are several
reasons for this:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Licenses:&lt;/strong&gt; If a vendor licenses individual copies of the software, they
want to prevent unrestricted copying of the software without paying for a
license.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Intellectual Property:&lt;/strong&gt; A vendor may have trade secrets or other
proprietary information that is disclosed by the source code.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Security:&lt;/strong&gt; Full access to the source code may reveal vulnerabilities in
the software or related systems. This is sometimes called &lt;em&gt;Security Through
Obscurity&lt;/em&gt; and is generally disparaged, but things are not so black and
white and there may be valid security concerns in the source code.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;The process that separates the source code from the executable program is
typically a compilation step. However, Ruby code is not typically associated
with any sort of compilation. That's one of the great things about Ruby,
right? There is no &lt;em&gt;edit-compile-link-load&lt;/em&gt; cycle to wait on. Just edit and run. But
if there is no compilation step, how do we separate the source code from the
executable code?&lt;/p&gt;

&lt;p&gt;You may recall from my &lt;a href=&quot;http://rubini.us/2011/03/11/making-rubinius-rbc-files-disappear/&quot;&gt;last
post&lt;/a&gt; that
Rubinius does compile Ruby code to a bytecode format that the virtual machine
executes. I also promised to explain how you could run the bytecode directly.&lt;/p&gt;

&lt;p&gt;But first, let me very clearly state that there are a number of caveats. In
fact, I've included a whole section on them below. Please read them. We will
assume that you have and that you understand them. If you have any questions,
please ask.&lt;/p&gt;

&lt;h3&gt;Application Distribution Scenario&lt;/h3&gt;

&lt;p&gt;Let's review what we would like to accomplish. We'll assume affable Abe is a
developer writing an application for customer Cain.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Abe writes some Ruby code.&lt;/li&gt;
&lt;li&gt;Abe compiles the code to a set of files.&lt;/li&gt;
&lt;li&gt;Abe packages the files up into an application with no Ruby source.&lt;/li&gt;
&lt;li&gt;Abe sends the application to Cain.&lt;/li&gt;
&lt;li&gt;Cain installs the application.&lt;/li&gt;
&lt;li&gt;Cain runs the application.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;In this scenario, I'm assuming a very vague definition of application. In
other words, the process below will fit in with a broad spectrum of bundling
and distribution schemes.&lt;/p&gt;

&lt;h3&gt;Application Layout&lt;/h3&gt;

&lt;p&gt;Let's assume that you have the following application layout. This mirrors what
you would expect to see in a gem. You could also consider this as a subtree in
your larger project.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;widget
|- lib
|- widget.rb
\- widget
   |- red.rb
   |- blue.rb
   \- green.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# widget.rb&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;widget/red&amp;#39;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;widget/blue&amp;#39;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;widget/green&amp;#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;




&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# widget/red.rb&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;I am red&amp;quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;




&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# widget/blue.rb&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;I am blue&amp;quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;




&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# widget/green.rb&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;I am green&amp;quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Compiling Ruby Files&lt;/h3&gt;

&lt;p&gt;The Rubinius bytecode compiler is accessible through a command-line script.
See &lt;code&gt;rbx compile -h&lt;/code&gt; for all options. We will only need one simple option in
our case to easily create a separate tree containing one compiled file for
every Ruby source file in our source tree.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rbx compile -s '^widget:widget-compiled' widget/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let's dissect this command. The &lt;code&gt;-s&lt;/code&gt; option defines a transformation to apply
to every filename. The transformation has the form &lt;code&gt;&amp;lt;source&amp;gt;:&amp;lt;destination&amp;gt;&lt;/code&gt;
where &lt;code&gt;&amp;lt;source&amp;gt;&lt;/code&gt; can be a Regexp. In our case, we would like to change any
path starting with &lt;code&gt;widget&lt;/code&gt; to start with &lt;code&gt;widget-compiled&lt;/code&gt;. This way, we
create a separate tree of our compiled files. The final option is the
&lt;code&gt;widget/&lt;/code&gt; directory. The &lt;code&gt;rbx compile&lt;/code&gt; command will happily compile a single
file or a directory of files. Note that if we did not pass the &lt;code&gt;-s&lt;/code&gt; option,
&lt;code&gt;rbx compile&lt;/code&gt; would have created the compiled files alongside the source
files.&lt;/p&gt;

&lt;p&gt;If we now look at &lt;code&gt;widget-compiled&lt;/code&gt;, we should see the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;widget-compiled
|- lib
|- widget.rbc
\- widget
   |- red.rbc
   |- blue.rbc
   \- green.rbc
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Loading Pre-compiled Files&lt;/h3&gt;

&lt;p&gt;Now that we have a separate tree of only compiled files, how do we load them?
Well, first, let's load our source files so we know what to expect. Note that
the technique used in this post should not substitute for a robust test suite.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rbx -Iwidget/lib -e &quot;require 'widget/lib/widget'&quot;
I am red
I am blue
I am green
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, that is what I would expect. Now, to load the compiled files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rbx -Iwidget-compiled/lib -e &quot;Rubinius::CodeLoader.require_compiled 'widget/lib/widget'&quot;
I am red
I am blue
I am green
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;The crowed erupts with applause and hooting&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Golly gee, you guys... &lt;em&gt;Blush&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Let's review. Our goal is to take a tree of Ruby source files and create a
tree of compiled files that can be sent to a customer and loaded to perform
exactly as the Ruby source would if loaded directly. The most direct and
simple way to accomplish this is to use the Rubinius compiler command-line
script to compile the tree of Ruby source files to a separate tree. Then, load
the root of that tree with &lt;code&gt;Rubinius::CodeLoader.require_compiled &quot;root&quot;&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Caveats&lt;/h3&gt;

&lt;p&gt;I will admit, I have resisted fiercely against encouraging or even permitting
Rubinius users from using what I showed above in their code. Not because I am
an ogre who is trying to steal your fun, but because there are serious issues
with allowing this. So, please read the following carefully.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We, Rubinius, absolutely reserve the right to change any part of the
underlying compiled file mechanism. Since we are publishing the
&lt;code&gt;Rubinius::CodeLoader.require_compiled(name)&lt;/code&gt; method, we will respect that
contract. What it says is, given a name, we will load a representation of
that name. &lt;em&gt;DO NOT assume that &lt;code&gt;&quot;some_file&quot;&lt;/code&gt; is actually referencing
&lt;code&gt;&quot;some_file.rbc&quot;&lt;/code&gt;&lt;/em&gt;. We may change the way compiled files are stored and may
change the format of the compiled output.&lt;/li&gt;
&lt;li&gt;We have created this facility to meet a need we had in Rubinius. Since our
compiler is written in Ruby, we have to run Ruby to run the compiler. But
since we need to compile Ruby to run it, we need to compile the compiler.
But since... To handle this, we build the compiler using a bootstrapping
version of Ruby.  Then we load the pre-compiled compiler files as shown
above. The approach is quite general, as demonstrated. However, a better
approach may be appropriate for a particular application. In that case,
talk to us about how you think it should work and we can point you in a
direction to try implementing what you need.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;We assume no responsibility for any security breaches resulting from your
incorrect assumption that .rbc files provides any meaningful security
mechanism.&lt;/strong&gt; I cannot stress this enough. The compiled file mechanism is a
cache. It is a way to avoid recompiling Ruby source code that has not
changed. The compiled format is simple. We reserve the right to provide
disassemblers for our compiled code. We are happy to assist you with
direction for implementing a more secure system for your needs.&lt;/li&gt;
&lt;li&gt;There is no mechanism that is completely safe from cracking when it comes
to software access control. Witness how often Microsoft's products have
their security features defeated. Also witness how often attempts at DRM
are circumvented. The most secure system I have seen uses a special
compiler and a hardware dongle. The compiler takes critical parts of the
application logic and breaks them up so that part of the computation is
performed on the dongle. This is significantly harder to defeat than binary
editing an executable to turn a license key check into a no-op. The folks
you most want to keep from accessing your information are the ones most
capable of doing so. Security and access control are very hard problems.&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Rubinius compiles Ruby code to bytecode before running it. It is possible to
save the bytecode representation and reload it later. Using this mechanism, it
is possible to avoid providing the Ruby source code and run an application
directly from the compiled bytecode. The mechanism we use to do this was
created to solve our problem of bootstrapping the Rubinius bytecode compiler,
which is written in Ruby. The mechanism is not intended to be used for
security.&lt;/p&gt;

&lt;p&gt;It is possible to extend the Rubinius code loading mechanism to support custom
formats for on-disk compiled bytecode and to load those formats. This can be
done entirely in Ruby code. If this interests you, please talk with us about
it.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Making Rubinius .rbc Files Disappear</title>
    <id>http://rubini.us/2011/03/11/making-rubinius-rbc-files-disappear/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2011/03/11/making-rubinius-rbc-files-disappear/" />
    <updated>2011-03-11T00:00:00-06:00</updated>
    <author>
      <name>Brian Ford</name>
    </author>
    
    <content type="html">&lt;p&gt;Rubinius is rather unusual as a Ruby implementation. It both compiles Ruby
source code to bytecode &lt;em&gt;and&lt;/em&gt; saves the compiled code to a cache so it does
not need to recompile unless the source code changes. This can be great for
utilities that are run often from the command line (including IRB). Rubinius
merely reloads the cached file and runs the bytecode directly rather than
needing to parse and compile the file. Sounds like a real win!&lt;/p&gt;

&lt;p&gt;Unfortunately, it is not that simple. We need some place to store that cache
and this is where the thorns on that pretty rose start poking us in the
thumbs. The solution we have been using since forever is to store the cached
file alongside the source file in the same directory, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ echo 'puts &quot;hello!&quot;' &amp;gt; hello.rb
$ ls hello.*
hello.rb
$ rbx hello.rb
hello!
$ ls hello.*
hello.rb    hello.rbc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That doesn't look too crazy, but it can get more complicated:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mv hello.rb hello
$ rbx hello
$ ls hello.*
hello.compiled.rbc  hello.rbc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whoa, what is &lt;code&gt;hello.compiled.rbc&lt;/code&gt;? Since &lt;code&gt;hello&lt;/code&gt; did not have an extension,
we add that longer &lt;code&gt;compiled.rbc&lt;/code&gt; to make it clear which file the cache is
for. Also, note that we have that &lt;code&gt;hello.rbc&lt;/code&gt; hanging about even though the
original &lt;code&gt;hello.rb&lt;/code&gt; is gone.&lt;/p&gt;

&lt;p&gt;To summarize the issues with our caching scheme:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;It requires an additional file for every Ruby source file.&lt;/li&gt;
&lt;li&gt;It requires some potentially complicated naming scheme to associate the
cache file with the source and not clash with other names.&lt;/li&gt;
&lt;li&gt;Removing or renaming the Ruby source file leaves the cache file behind.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Again, the advantage of the cache file is that you do not have to wait for
Rubinius to recompile the file if you have not changed the source. Let's see
if we can get all the advantages with none of the disadvantages. That old
saying comes to mind, &lt;em&gt;Having your cake and eating it, too&lt;/em&gt;, so we may not
be successful, but it is worth a shot.&lt;/p&gt;

&lt;p&gt;First, let's take a step back. This issue is not unique to Rubinius. Python
has &lt;code&gt;.pyc&lt;/code&gt; and &lt;code&gt;.pyo&lt;/code&gt; files. Java has &lt;code&gt;.class&lt;/code&gt; files. C/C++ has &lt;code&gt;.o&lt;/code&gt; files.
Lots of things need a place to store a compiled or cached representation of
some data. Every SCM worth mention has some mechanism to ignore the files you
don't want to track. The same is generally true of editors. So in some sense,
this is a solved problem. However, we have always received complaints about
the &lt;code&gt;.rbc&lt;/code&gt; files, so we thought we would try to make other, hopefully better,
solutions available.&lt;/p&gt;

&lt;h3&gt;Solution 1: No Cache&lt;/h3&gt;

&lt;p&gt;One simple solution is just to never ever ever create the compiled cache files
in any form anywhere. We have an option for that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls hello.*
hello.rb
$ rbx -Xcompiler.no_rbc hello.rb
hello!
$ ls hello.*
hello.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Win! Not one lousy &lt;code&gt;.rbc&lt;/code&gt; file in sight. Although, that's quite the option to
type. Never fear, we have a solution to that below.&lt;/p&gt;

&lt;p&gt;Here is our scorecard for solution 1:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Use Case:&lt;/strong&gt; Use when you never want any compiler cache files created. For
example, on a server where startup time is not really a concern.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pros:&lt;/strong&gt; No &lt;code&gt;.rbc&lt;/code&gt; files at all.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cons:&lt;/strong&gt; Startup will be slightly slower depending on what Ruby code you are
running. It will be more noticeable in a Rails application, for example.
However, the Rubinius bytecode compiler is several times faster than it was a
couple years ago so it may not be an issue for you.&lt;/p&gt;

&lt;h3&gt;Solution 2: Cache Database&lt;/h3&gt;

&lt;p&gt;What if we could put all the compilation data in a single cache location,
something like a database? We have an option for that.&lt;/p&gt;

&lt;p&gt;This option is a little more complex, so let's take it in two steps.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls hello.*
hello.rb
$ rbx -Xrbc.db hello.rb
hello!
$ ls hello.*
hello.rb
$ ls -R .rbx
60

.rbx/60:
60c091c3ed34c1b93ffbb33d82d810772902d3f9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Success! No &lt;code&gt;.rbc&lt;/code&gt; files here. But what's with all the numbers in the &lt;code&gt;.rbx&lt;/code&gt;
directory and how did that directory get there?&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;-Xrbc.db&lt;/code&gt; option without any argument will store the compilation cache in
the &lt;code&gt;.rbx&lt;/code&gt; directory in the current working directory. The cache files
themselves are split into subdirectories to avoid creating too many entries
for the file system to handle in one directory.&lt;/p&gt;

&lt;p&gt;What if you have a special location where you would prefer all compilation
cache files be saved? No problem, just give &lt;code&gt;-Xrbc.db&lt;/code&gt; a path as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls hello.*
hello.rb
$ rbx -Xrbc.db=$HOME/.my_special_place hello.rb
hello!
$ ls hello.*
hello.rb
$ ls -R $HOME/.my_special_place
60

/Users/brian/.my_special_place/60:
60c091c3ed34c1b93ffbb33d82d810772902d3f9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you primarily work with projects, putting the &lt;code&gt;.rbx&lt;/code&gt; directory in the
current working directory may be the best solution because it keeps the
compilation cache with the project. It is easy to add an SCM ignore for the
directory and easy to remove the directory to clear the cache (e.g. in a clean
task).&lt;/p&gt;

&lt;p&gt;However, if you are frequently running scripts in many directories, you may
not want to litter &lt;code&gt;.rbx&lt;/code&gt; directories everywhere. In this case, putting the
directory in your &lt;code&gt;$HOME&lt;/code&gt; dir or &lt;code&gt;/tmp&lt;/code&gt; may be preferable. Additionally,
&lt;code&gt;/tmp&lt;/code&gt; may be cleared on every reboot so you will not accumulate many stale
cache files.&lt;/p&gt;

&lt;p&gt;Note that, right now, Rubinius does not clear the cache directory. It will
happily continue adding to it indefinitely. However, this may not be an issue
unless you are cycling through a bunch of Ruby files, for example, working on
a number of Ruby projects in series. In that case, using a per-project (per
current working directory) cache is probably the best option.&lt;/p&gt;

&lt;p&gt;Here is how solution 2 shakes out:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Use Case:&lt;/strong&gt; You want to combine all compilation cache files in one location.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pros:&lt;/strong&gt; No &lt;code&gt;.rbc&lt;/code&gt; files mixed in with the rest of your files.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cons:&lt;/strong&gt; You may still need a per-project or per-working-directory cache
directory. However, you can easily specify where to put that directory.&lt;/p&gt;

&lt;h3&gt;Using RBXOPT for Options&lt;/h3&gt;

&lt;p&gt;As mentioned above, the &lt;code&gt;-X&lt;/code&gt; options can get a little long and you certainly
don't want to retype them constantly. We have added support for the &lt;code&gt;RBXOPT&lt;/code&gt;
environment variable, which is an analog of the &lt;code&gt;RUBYOPT&lt;/code&gt; environment variable
that we already support.&lt;/p&gt;

&lt;p&gt;Use &lt;code&gt;RBXOPT&lt;/code&gt; to specify &lt;code&gt;-X&lt;/code&gt; options that Rubinius should use. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export RBXOPT=-Xrbc.db=/path/to/dir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can check out all the &lt;code&gt;-X&lt;/code&gt; options with &lt;code&gt;rbx -Xconfig.print&lt;/code&gt; or &lt;code&gt;rbx
-Xconfig.print=2&lt;/code&gt; for more verbose output. If you want to use multiple &lt;code&gt;-X&lt;/code&gt;
options in &lt;code&gt;RBXOPT&lt;/code&gt;, use quotes and separate the options with a space:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export RBXOPT='-Xrbc.db -Xagent.start'
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Rubinius saves a compilation cache for compiled Ruby code to avoid wasting
time and resources recompiling source that has not changed. However, we need
some place to store the cache. Rubinius provides options for omitting the
cache altogether or for storing it in a directory of your choosing. Note that
the format of the compilation cache is an implementation detail and we reserve
the right to change it at any time, so please don't rely on it being in any
particular format.&lt;/p&gt;

&lt;p&gt;We have not turned on &lt;code&gt;-Xrbc.db&lt;/code&gt; by default yet because we don't know what a
good default is. So give us feedback on your use cases and what you would find
most useful.&lt;/p&gt;

&lt;p&gt;Finally, whenever we discuss the compilation cache we are inevitably asked if
you can run directly from the cache and not use the Ruby source at all after
it has been compiled. The short answer is &quot;Yes&quot;, the long answer is &quot;It
depends&quot;. I will be writing a post exploring this question in detail shortly.
For now, get out there and write more Ruby code!&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Why Use Rubinius</title>
    <id>http://rubini.us/2011/02/25/why-use-rubinius/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2011/02/25/why-use-rubinius/" />
    <updated>2011-02-25T00:00:00-06:00</updated>
    <author>
      <name>Brian Ford</name>
    </author>
    
    <content type="html">&lt;p&gt;&lt;em&gt;Why should I use Rubinius?&lt;/em&gt; We have been asked that question many, many times
over the past four years. It is a great question. It is an important question.
It's a &lt;em&gt;hard&lt;/em&gt; question. I'm not holding out on you. I want to give you an
answer that sates your curiosity, helps you make informed decisions, and
empowers you to speak eloquently when &lt;em&gt;you&lt;/em&gt; are inevitably asked, &quot;Why do you
use Rubinius?&quot;&lt;/p&gt;

&lt;p&gt;The trouble is, there are many different situations in which people use Ruby
and there is simply no answer, however comprehensive, that really speaks to
everyone's concerns. So rather that boring you at length, I thought a &lt;em&gt;Choose
your own adventure&lt;/em&gt; style would be a better approach.&lt;/p&gt;

&lt;p&gt;From the list below, select the persona that best describes you. Don't worry,
if the one you select doesn't sound right, you can easily backtrack here. Read
as many as interest you. After all, none of us fit easily into any one box.
When you are done exploring all the fascinating reasons to use Rubinius, let's
meet up at the &lt;a href=&quot;#wur-conclusion&quot;&gt;Conclusion&lt;/a&gt; for some parting
words.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Enjoy!&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a class=&quot;anchor_title&quot; name=&quot;wur-personas&quot;&gt;Choose Your Persona&lt;/a&gt;&lt;/h3&gt;


&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#wur-newby&quot;&gt;Rails or Ruby Newby&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#wur-creative&quot;&gt;The Creative&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#wur-experienced&quot;&gt;Experienced Programmer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#wur-seasoned&quot;&gt;Seasoned Programmer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#wur-academic&quot;&gt;Academic Researcher&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#wur-uber&quot;&gt;ber Programmer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#wur-philosophical&quot;&gt;Philosophy Student Seeking the Meaning of Ruby&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#wur-manager&quot;&gt;Manager&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#wur-knowledge&quot;&gt;Knowledge Seeker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#wur-enthusiast&quot;&gt;Language Enthusiast&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;&lt;a class=&quot;anchor_title&quot; name=&quot;wur-newby&quot;&gt;Rails or Ruby Newby&lt;/a&gt;&lt;/h4&gt;


&lt;p&gt;You are pretty new to programming and after hearing about Ruby on Rails you
watched a screencast and made a website. You are curious and enthusiastic.&lt;/p&gt;

&lt;p&gt;You are the empty teacup of the Zen proverb. You are a fresh-faced flower
glistening with the morning dew. The sun smiles on you and you smile back.
You seem to like this Ruby language that makes programmers happy and you've
come to lend your cheery spirit...&lt;/p&gt;

&lt;p&gt;Welcome!&lt;/p&gt;

&lt;p&gt;So, you have heard of this thing called Rubinius or rbx or whatever and some
folks you respect or admire seem to like it and naturally you want to know
what the big deal is and you're like, &quot;Yo, why would I use Rubinius?&quot;.&lt;/p&gt;

&lt;p&gt;Cool.&lt;/p&gt;

&lt;p&gt;Well, you should use Rubinius because I said so. Try your code on it. Tell us
what worked for you. Tell us if something didn't work by opening an
&lt;a href=&quot;https://github.com/rubinius/rubinius/issues/&quot;&gt;issue&lt;/a&gt;.
Set your imagination loose and tell us what tool you would use if you could.&lt;/p&gt;

&lt;p&gt;Spend some time reading the Rubinius source code. Start at the &lt;code&gt;kernel/&lt;/code&gt;
directory. It's full of Ruby code! As you read through how Ruby is
implemented, how it actually works, it will give you a level of understanding
of your code that many programmers don't have in &lt;em&gt;any&lt;/em&gt; language.&lt;/p&gt;

&lt;p&gt;Most of all, hang on to your curiosity and enthusiasm. Those were vital to the
creation of the Rubinius project in the beginning and have sustained us
through many challenges. We &lt;em&gt;can&lt;/em&gt; make our Ruby experience better, freeing us
from the shackles of other languages and foreign libraries. We &lt;em&gt;can&lt;/em&gt; have fast
and reliable web servers, games, editors, websites and applications written in
Ruby. We &lt;em&gt;can&lt;/em&gt; have first class tools written for and with Ruby. The world
&lt;em&gt;can&lt;/em&gt; be rosy red without our glasses.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#wur-personas&quot;&gt;&lt;strong&gt;Back to personas&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;&lt;a class=&quot;anchor_title&quot; name=&quot;wur-creative&quot;&gt;The Creative&lt;/a&gt;&lt;/h4&gt;


&lt;p&gt;Ruby is groovy. No, not that Groovy, eww, no. I mean:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;groovy |grov| adj.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;fashionable and exciting : &lt;em&gt;sporting a groovy new haircut&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;enjoyable and excellent : &lt;em&gt;he played all the remarkably groovy guitar parts
himself&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(Apple's dashboard dictionary widget.)&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt;Ruby respects creativity. It has an &lt;em&gt;aesthetic&lt;/em&gt;. You don't just write Ruby
code, you write &lt;em&gt;beautiful&lt;/em&gt; Ruby code.  It would be unthinkable to do
otherwise. Sure, there is more than one way to do many things. This is not
some sterile laboratory. We are not automatons; we are people. Of course,
being utilitarian is not bad. But other languages have that angle pretty
well covered. There is probably only one right way to implement Python.&lt;/p&gt;

&lt;p&gt;Rubinius has an aesthetic, too: excellence, utility, simplicity, beauty, joy.
Mostly in that order. Useful code that isn't of very good quality is a drag.
It slows you down. It gives you a headache. It drives you away. We strive to
keep it out of Rubinius. On the other hand, we are not just writing sonnets
here. This is Serious Business. We have some hard-core problems to solve. So
we strive for excellent, useful, beautiful code that is a joy to work with.&lt;/p&gt;

&lt;p&gt;Of course, this is an ongoing process. It is a journey, not a destination.
There are areas of Rubinius that could use a thorough cleaning or a new
perspective on making the implementation of this beautiful object-oriented
language more beautiful and object-oriented.&lt;/p&gt;

&lt;p&gt;We welcome your artistic perspective. Help us improve the dialog between
Rubinius and the person using it. The command line doesn't have to be a
desolate place of obscure, condescending error messages. Web interfaces to the
diagnostic tools deserve a good dose of user-experience and interaction
design. You know that feeling you get when looking at an Enterprise web
application? That weird plastic-masquerading-as-quality-material feeling?
The too much 1996-Enterprise-faux-rounded-corner-wanabe-2006-hip gloss?
Gives me the willies whenever I have to use an app like that. Yeah, we don't
want that.&lt;/p&gt;

&lt;p&gt;We want to create tools that are powerful, graceful, easy to use, and
beautiful to look at. Beautiful tools are easier to use. (Yehuda Katz provided
a couple links related to this: &lt;a href=&quot;https://www.westga.edu/~distance/ojdla/winter134/david_glore134.html&quot;&gt;The Impact of Design and Aesthetics on
Usability, Credibility, and Learning in an Online Environment
&lt;/a&gt; and
&lt;a href=&quot;http://www.alistapart.com/articles/indefenseofeyecandy&quot;&gt;In Defense of Eye
Candy&lt;/a&gt;. If you know of
other research, leave us a comment.) So if you have a creative bent but enjoy
writing code also, try out Rubinius and let us know where it could use some
polish.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#wur-personas&quot;&gt;&lt;strong&gt;Back to personas&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;&lt;a class=&quot;anchor_title&quot; name=&quot;wur-experienced&quot;&gt;Experienced programmer&lt;/a&gt;&lt;/h4&gt;


&lt;p&gt;That saying, &lt;em&gt;Time is Money&lt;/em&gt;, you live by it. You have applications to deliver
and you choose the best tool for the job. You are professional, conscientious,
duly cautious, and not inclined to episodes of emotional exuberance about the
latest fad. You accept compromises. There are always trade-offs. The correct
approach is cost-benefit analysis. The numbers tell the story and level-headed
decision making follows the numbers.&lt;/p&gt;

&lt;p&gt;You have heard about Rubinius and you are curious whether it may be
appropriate for your current project. As usual, rather than speculating or
paying too much heed to the buzz, you look into it yourself. After some
investigation, you discover that:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Much of Rubinius is implemented in Ruby itself. This may be a big help when
tracking down troublesome bugs.&lt;/li&gt;
&lt;li&gt;Rubinius has a very fast bytecode virtual machine, as well as a modern
generational garbage collector so memory profiles should be more
predictable and consistent in deployed applications.&lt;/li&gt;
&lt;li&gt;It has a profile-driven JIT compiler that uses type-feedback to
aggressively inline methods resulting in significant performance
improvements.&lt;/li&gt;
&lt;li&gt;It has a built-in debugger and precise method profiler, both of which are
fast due to being well integrated.&lt;/li&gt;
&lt;li&gt;It has a built-in API for monitoring a VM out-of-process, even on a remote
machine. We are building a variety of diagnostic tools atop this API.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Of course, even if the technology in Rubinius sounds terrific in theory, how
suitable is Rubinius for your application? How does it perform under your
specific constraints? Again, you do some investigating. You have a solid test
suite for your application, so you start by running that. If you hit any
problems, please open an &lt;a href=&quot;https://github.com/rubinius/rubinius/issues/&quot;&gt;issue&lt;/a&gt;
to let us know.&lt;/p&gt;

&lt;p&gt;If everything goes well with the tests, you start running some of the
benchmarks that you have accumulated while doing performance tuning. Of
course, no sensible person asks for benchmark results from &lt;em&gt;other&lt;/em&gt; people's
code. That defies logic. It's like asking if your program will run because
your Aunt Mabeline likes decaf coffee. It's contrary to the very point of
benchmarking, where you are trying to correlate two values that are connected.&lt;/p&gt;

&lt;p&gt;Again, if you note an significant issues, please let us know. Sometimes
Rubinius exposes issues in existing code. Performance characteristics of real
applications are vital to making Rubinius faster. Also, if you have
suggestions for tools you would like to use, tell us. If you just want to
chat about the technology, that's fine, too. We're hanging out in the&lt;/p&gt;

&lt;h1&gt;rubinius channel on freenode.net.&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;#wur-personas&quot;&gt;&lt;strong&gt;Back to personas&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;&lt;a class=&quot;anchor_title&quot; name=&quot;wur-seasoned&quot;&gt;Seasoned programmer&lt;/a&gt;&lt;/h4&gt;


&lt;p&gt;Well, I am being kind by saying &lt;em&gt;seasoned&lt;/em&gt;. You know when you look in the
mirror that &lt;em&gt;jaded&lt;/em&gt; and &lt;em&gt;cynical&lt;/em&gt; are much more apt. You've seen it all and it
has worn you down. You've been fighting the good fight, carefully guarding
that last flicker of optimism that burns in the secret place deep in your
heart. You've programmed Java/.NET/C++ professionally. You've even sucked it
up and written some PHP and Python when asked; you are a professional, they
ask and you deliver. You've seen attacked servers on fire off the shoulder of
Rackspace...&lt;/p&gt;

&lt;p&gt;Rubinius has a lot to offer you. Remember that little flicker of optimism?  It
is only the idealists that get ground down by the complete indifference to
pursuit of an ideal in so much of the world. Deep down, you are an idealist
and you will find plenty to refresh you here.&lt;/p&gt;

&lt;p&gt;Rubinius aims to be the best possible implementation of Ruby by putting Ruby
itself front and center. We are using modern technology and always improving.
We change when there is a better way to do things. We judiciously rewrite and
are not too attached to any code or algorithm. The legacy Enterprise isn't on
the steering committee. Our work will be done when you can use Ruby, just
Ruby, to solve your thorny problems.&lt;/p&gt;

&lt;p&gt;Sure, that sounds idealistic. But never mind the pessimists that tell you that
you have to compromise. If you are not idealistic, you will not be unsatisfied
with things that are not as good as they could be; you will not try to change
the world. So give Rubinius a try, you may be surprised. And if you are, put
all that hard-earned wisdom you have gained to use for the betterment of Ruby.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#wur-personas&quot;&gt;&lt;strong&gt;Back to personas&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;&lt;a class=&quot;anchor_title&quot; name=&quot;wur-academic&quot;&gt;Academic Researcher&lt;/a&gt;&lt;/h4&gt;


&lt;p&gt;Forgive me for staring, I know it is impolite. I'm just... intrigued. Of
course, you know Ruby is a late bound language, every message sent could
conceivably fail to find a target, potentially resulting in an uncaught
exception and program termination. There's shared state, wild orgies of
mutation that disallow any reasonable attempt at automated parallelization.
Program proof is as oxymoronic a concept as military intelligence. It's a very
messy affair of programming and meta-programming and meta-meta-programming,
which, for the love of Lisp, could be done so simply with macros. There's all
this eager evaluation and complete disregard for purity. Despite vast odds,
somehow programs are written that actually run. You have noted all this with
great objectivity but you are nonetheless interested.&lt;/p&gt;

&lt;p&gt;Excellent, we are pleased. We have much to learn and welcome the opportunity
for lively discussions about bringing formal methods to bear on the problems
of making Ruby as fast as possible.&lt;/p&gt;

&lt;p&gt;Java benefited tremendously from the amount of attention it received by
academic researchers. Ruby can benefit from some of this research as well, not
to mention the research into Smalltalk and Self that preceded it. But Ruby has
its own set of problems to solve and deserves specific attention. The problems
are hard but not insurmountable. Rubinius is already demonstrating that.  The
suggestion that we need to add more keywords, restrict Ruby dynamism, or write
&lt;code&gt;public static final int&lt;/code&gt; all over are simply nonsense.&lt;/p&gt;

&lt;p&gt;Rubinius already leverages research for fast virtual machines, garbage
collection (e.g. the generational approach and the Immix &lt;em&gt;mark-region&lt;/em&gt;
algorithm), and JIT compilers (based on pioneering research done in Self and
used in the JVM Hotspot VM). Rubinius uses the exceptional
&lt;a href=&quot;http://llvm.org&quot;&gt;LLVM&lt;/a&gt; project for optimization and code generation in the
JIT compiler. We are also working on better infrastructure for the JIT to
address Ruby complexities head-on.&lt;/p&gt;

&lt;p&gt;Rubinius would be excellent to use in teaching. A compiler construction class
could study the architecture of the bytecode compiler written in Ruby and
experiment with exploratory changes to the compiler using IRB without having
to recompile anything! A 30-minute introduction to Rubinius could proceed
immediately to simple AST generation and have students experimenting with
their own syntax immediately. While it is easy to get started, there is plenty
of depth for exploring complex topics in virtual-machine construction and
garbage collection.&lt;/p&gt;

&lt;p&gt;Whether you are interested in language research or language pedagogy, Rubinius
is an great project to consider. We look forward to hearing from you.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#wur-personas&quot;&gt;&lt;strong&gt;Back to personas&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;&lt;a class=&quot;anchor_title&quot; name=&quot;wur-uber&quot;&gt;ber programmer&lt;/a&gt;&lt;/h4&gt;


&lt;p&gt;You learned the untyped lambda calculus sitting on your mother's knee while
she worked on her doctorate in computer science. You were substituting terms
before you even uttered the word, &quot;dada&quot;. You wrote three different Lisp
implementations in Commodore Basic before you were seven. You can write
multi-threaded web servers in one pass with no tests and never hit a deadlock
or critical data race. You write parsers and compilers for odd languages on a
Friday night for the heck of it while waiting for the pizza to arrive before a
night out at the karaoke bar where you give an inspiring performance of Laga
Gaga's &lt;em&gt;Poker Face&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;(&lt;em&gt;Loooong pause&lt;/em&gt;. You're not reading this. You've already written one or a few
languages on Rubinius and posted them to our
&lt;a href=&quot;http://rubini.us/projects/&quot;&gt;Projects&lt;/a&gt; page. But anyway, I'll continue...)&lt;/p&gt;

&lt;p&gt;You are the Luke Skywalker of Ruby; Yoda has nothing more to teach you. Only
your fate confronts you now. Use the Source Luke and save the Federation of
Ruby loyalists from the Evil Oracle and its Java the Hurt.&lt;/p&gt;

&lt;p&gt;There are a number of domains in which Ruby could benefit tremendously from
excellent libraries:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Servers and web servers&lt;/strong&gt;: the web is here to stay but the argument that all
applications are going to be in Javascript on the client is not valid. A variety
of hybrid client-server architectures will continue to be the norm. We need
software that enables application authors to build a suitable solution to
their particular problems rather than trying to stuff their apps into
someone else's solution with layers of wrapping.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Concurrency&lt;/strong&gt;: multi-core is here to stay but it is not only functional
programming that is suitable for high-concurrency applications.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Graphical user interface&lt;/strong&gt;: the web browser is also here to stay but it is
not the last word in applications. There are many cases where GUI apps are
the best option and Ruby needs a mature library or set of libraries to
build these apps on any major platform. I know some of these libraries
exist, but they seem to be collecting dust lately.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Big data and data analysis libraries&lt;/strong&gt;: our industry repeatedly witnesses
the same pattern: domain X starts with huge applications running on huge
horsepower servers for huge businesses and then it starts appearing in small
applications on small computers for small businesses. Accounting and
geographic information systems (GIS) are two examples. Data analysis is
coming to a laptop near you.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;These are general areas in which Ruby can be an excellent solution. So how
does Rubinius fit in? Rubinius is dedicatedly pushing more and more into Ruby
itself. Each of these domain is typically handled in Ruby right now by going
to find a library in a foreign language to wrap in a fuzzy Ruby embrace.
Rubinius is calling on the ber-programmers of the world to implement
solutions in Ruby to help us identify performance challenges and address them.&lt;/p&gt;

&lt;p&gt;Rubinius is also being used in some fascinating language experiments. Two of
these are Atomo (&lt;a href=&quot;http://atomo-lang.org&quot;&gt;http://atomo-lang.org&lt;/a&gt; which is
implemented in Haskell, with a Rubinius implementation code-named
&lt;a href=&quot;https://github.com/vito/quanto/&quot;&gt;quanto&lt;/a&gt;) and Fancy
(&lt;a href=&quot;http://fancy-lang.org&quot;&gt;http://fancy-lang.org&lt;/a&gt;). So, if language design is
your cup of tea, Rubinius offers an excellent platform for experimentation.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#wur-personas&quot;&gt;&lt;strong&gt;Back to personas&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;&lt;a class=&quot;anchor_title&quot; name=&quot;wur-philosophical&quot;&gt;Philosophy Student Seeking the Meaning of Ruby&lt;/a&gt;&lt;/h4&gt;


&lt;p&gt;Like your persona description, you tend to be long winded. You find most
descriptions too brief, almost dismissive. There are words and words should be
used to delve into the minutiae of minutiae. You, more than anyone, want to
know &quot;Why?&quot; with every fiber of your being. You will continue asking long
after the supply of hallucinogens has been exhausted and everyone else is
drooling in their sleep.&lt;/p&gt;

&lt;p&gt;For you, Rubinius is an existential dilemma crying out for justification. If
we already have MRI, why build Rubinius?&lt;/p&gt;

&lt;p&gt;It would be accurate to say that Rubinius has a philosophy. That philosophy is
simply this: &lt;em&gt;Ruby should be a first class language&lt;/em&gt;. What does that mean?
Simply that it should be possible to solve problems writing Ruby code.&lt;/p&gt;

&lt;p&gt;Let's consider libraries: Being first class means not having to wrap a Java
library or build a C extension. If wrapping the library were the end of the
story, it wouldn't be so bad. But that is &lt;em&gt;never&lt;/em&gt; the case. Libraries have
bugs, weird APIs, incompatibility with other libraries, threading issues, and
disappearing maintainers. They may even be incompatible with newer versions of
the language in which they are written.&lt;/p&gt;

&lt;p&gt;This list goes on. To address any one of these issues requires delving into a
different language with weird and incompatible semantics. If the library is
your core competency, that's not such a big deal. But I will wager that it is
not, which is why you are using the library in the first place. Also, the
language in which you are wrapping the library (Ruby here) is not likely the
core competency of the library author, or you probably wouldn't need to be
wrapping it. So Ruby wrapping one of these libraries will always be a
second-class citizen. Decisions will be made about the library's API that do
not give one thought to the Ruby programs using it. Furthermore, the code
written in that foreign language does nothing to support the ecosystem of
Ruby. The knowledge gained in writing the library and the improved skills of
the library author do not benefit Ruby. Ruby deserves better.&lt;/p&gt;

&lt;p&gt;Ruby has gotten a big boost recently with the production release of MRI 1.9.2.
There are significant speed improvements and welcomed additions to the core
libraries, like powerful handling of String encodings. At the same time, the
Complex and Rational libraries were added to the core library and rewritten
from Ruby to C code. This is disappointing. We should be able to solve these
problems more effectively in Ruby itself.&lt;/p&gt;

&lt;p&gt;The philosophy of Rubinius is to make Ruby a first-class citizen. Ruby plays
second fiddle to no one. There is no other language whose history, semantics,
or vested interests compete with Ruby's. It is true that there are difficult
problems to solve in making Ruby fast. But much of the technology already
exists and we will build what does not. Evan often quips that if we can get
Rubinius caught up to the dynamic language technology of ten years ago, Ruby
will be light-years ahead.  That may be overstating how far behind Ruby is,
but it illustrates the focus of Rubinius.&lt;/p&gt;

&lt;p&gt;There's the saying, &lt;em&gt;In theory, there is no difference between theory and
practice. In practice, there is&lt;/em&gt;. In Rubinius, theory and practice are
merging. We are motivated by the desire for Ruby to be a first-class language.
But we are also showing real progress in making that a reality. The Rubinius
VM executes Ruby code blazingly fast. The JIT compiler, while still being
quite young, is showing great promise. Compatibility with MRI is quite good
and speed is constantly improving.&lt;/p&gt;

&lt;p&gt;Is the Rubinius philosophy valid? We think the proof is in the pudding.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#wur-personas&quot;&gt;&lt;strong&gt;Back to personas&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;&lt;a class=&quot;anchor_title&quot; name=&quot;wur-manager&quot;&gt;Manager&lt;/a&gt;&lt;/h4&gt;


&lt;p&gt;No, it did not cross my mind to describe this persona as Pointy-haired Boss.
Not only would that be unfair to Dilbert, but that persona would be reading an
article on Web Scale. No, you are someone who has fought hard battles in the
trenches and learned valuable lessons: it's about execution and execution
depends on good technology.&lt;/p&gt;

&lt;p&gt;Rubinius is building solid technology. We started the RubySpec project and
have contributed tens of thousands of lines of code to it. With the support of
Rubyspec, in just over four years as a public project, we have basically
caught up with MRI 1.8.7 in compatibility and performance. For some code, our
performance is much better, for other code, it is not as good. However,
Rubinius is built on solid, modern technology and the project's trajectory and
velocity are outstanding.&lt;/p&gt;

&lt;p&gt;Rubinius is a completely new implementation of core Ruby. Rubinius did not
start as a port of existing code. Furthermore, Rubinius implements its own
virtual machine and garbage collector in C++. The bytecode compiler that
targets the virtual machine is pure Ruby. The core Ruby library is mostly Ruby
with some primitive operations in C++. The JIT compiler uses the
&lt;a href=&quot;http://llvm.org&quot;&gt;LLVM&lt;/a&gt; project. Given the amount of work being done in the
project, Rubinius is pacing extremely well relative to other implementations.&lt;/p&gt;

&lt;p&gt;Currently, we are working on support for Ruby 1.9 features, Windows support,
and full concurrency with no global interpreter lock (GIL).&lt;/p&gt;

&lt;p&gt;If you are looking at Ruby to implement your next project, rest assured that
Ruby will have the support of excellent technology. If you are already using
Ruby, consider investigating how your application runs on Rubinius. We welcome
the feedback and look forward to solving challenging engineering problems.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#wur-personas&quot;&gt;&lt;strong&gt;Back to personas&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;&lt;a class=&quot;anchor_title&quot; name=&quot;wur-knowledge&quot;&gt;Knowledge Seeker&lt;/a&gt;&lt;/h4&gt;


&lt;p&gt;You thirst for Knowledge. You follow it wherever it leads you. You'll happily
walk Haskell's hallowed halls of pure laziness or sit at the feet of the
meta-program gazing raptly at class transmorgrification. You don't judge. You
have more than enough knowledge to be dangerous, enough to know that the
universe is amoral and knowledge is the only Truth there is. Nor does any mere
mortal language bind you. All languages are finite. You'll be here today and
gone tomorrow; there is no permanence for the knowledge seeker.&lt;/p&gt;

&lt;p&gt;Rubinius is merely a step along the path you journey. Take what you want, it
is all free. As a Ruby implementation, it has much to offer your quest for
knowledge. The Ruby code in the core library is accessible and easy to follow.
The interface between Ruby and the C++ primitives is consistent. The C++ code
itself is restrained. You won't need a PhD in Turing-complete template
languages to understand it.&lt;/p&gt;

&lt;p&gt;Rubinius offers extensive opportunities to learn about programming languages
in general and Ruby in particular. When I first started working with Rubinius,
I knew a little bit about garbage collection and virtual machines. I would
call what I knew, toy knowledge. As I struggled to learn more, it seemed
helpful to consider layers of understanding:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;General programming language semantics&lt;/strong&gt;: the procedure abstraction,
looping and iteration, recursion, references and values, etc.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ruby semantics&lt;/strong&gt;: modules and classes, access restrictions, blocks and
lambdas, etc. Even with fundamental programming knowledge, a particular
language can be confusing. When I was learning C, a friend was also
studying it. One day he walked over and threw &lt;em&gt;The C Programming Language&lt;/em&gt;
book down on my desk and said, &quot;This &lt;code&gt;for&lt;/code&gt; loop makes no sense!&quot; He was
quite upset. &quot;Look,&quot; he said, &quot;in this example &lt;code&gt;for (i=0; i &amp;lt; n; i++)&lt;/code&gt; how
can &lt;code&gt;i &amp;lt; n&lt;/code&gt; get executed &lt;em&gt;after&lt;/em&gt; the code in the body?!&quot; It's easy to laugh
at that confusion, but coming from BASIC, that really threw him. Deepening
our understanding to this second level requires confronting some
&quot;counter-intuitive&quot; notions.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hypothetical implementation&lt;/strong&gt;: knowing how Ruby works, how might one
implement it. I think this is an important layer of understanding and it is
easy to miss or gloss over it. By pausing at this layer and thinking how
you might implement something, you test whether or not you are really
understanding it.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The MRI implementation&lt;/strong&gt;: Reading the MRI source code is an excellent way
to investigate Ruby. For one thing, it will inform you how Ruby &lt;em&gt;actually&lt;/em&gt;
works, and you may be surprised.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The Rubinius implementation&lt;/strong&gt;: here you are exposed to the philosophy of
Rubinius and the challenges to implementing Ruby. We are attempting to
bring the beauty of Ruby as an object-oriented language deep into the core
of Ruby itself.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;While the Rubinius code itself offers many opportunities for learning, don't
hesitate to drop by the #rubinius channel on freenode.net and ask us
questions. Perhaps you already know a lot about another language and are
interested in how Rubinius implements some feature. Or you may be relatively
new to programming languages and have some basic questions. We enjoy talking
about these concepts. If you are quite new to Rubinius, you may find these
posts informative:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.engineyard.com/blog/2010/making-ruby-fast-the-rubinius-jit/&quot;&gt;Making Ruby Fast: The Rubinius JIT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.engineyard.com/blog/2009/improving-the-rubinius-bytecode-compiler/&quot;&gt;Improving the Rubinius Bytecode Compiler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.engineyard.com/blog/2009/the-anatomy-of-a-ruby-jit-compile/&quot;&gt;Compiling Ruby: From Text to Bytecode&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Finally, consider helping other knowledge seekers by writing blog posts on
what you learn about Rubinius. Or, help us &lt;a href=&quot;http://rubini.us/doc/en/how-to/write-documentation/&quot;&gt;write documentation&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#wur-personas&quot;&gt;&lt;strong&gt;Back to personas&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;&lt;a class=&quot;anchor_title&quot; name=&quot;wur-enthusiast&quot;&gt;Language Enthusiast&lt;/a&gt;&lt;/h4&gt;


&lt;p&gt;You like languages for their intrinsic value. Of course the world comes in
many shapes and sizes. You wouldn't have it any other way. That's the fun and
spice, joie de vivre, raison d'etre, supermarch... Sometimes you get carried
away writing a program in another language just because you like how the
letters arrange down the screen. Ruby is definitely one of the impressive
languages and sometimes you almost notice a tiny bit of favoritism in your
normally egalitarian attitude.&lt;/p&gt;

&lt;p&gt;As with any enthusiast, you like to experiment. Your interest is not mere
curiosity or sterile investigation. You want to get your feet wet and your
hands dirty. Rubinius is an excellent opportunity to delve into a number of
fascinating subjects. We can merely suggest a path; your experiences along the
way will tell you whether or not Rubinius has value to you.&lt;/p&gt;

&lt;p&gt;If you are most interested in languages themselves, the syntax and arrangement
of features, Rubinius offers you immediate gratification. Look for Evan's
upcoming post on his Language Toolkit or check out the code to
&lt;a href=&quot;https://github.com/evanphx/prattle&quot;&gt;prattle&lt;/a&gt;, a Smalltalk dialect used to
illustrate the ease of building a language on Rubinius. Also look at some of
the existing languages &lt;a href=&quot;http://rubini.us/projects/&quot;&gt;projects&lt;/a&gt; targeting
Rubinius.&lt;/p&gt;

&lt;p&gt;If it is the machinery under the covers that is more interesting, start
reading some code. The bytecode compiler lives in &lt;code&gt;lib/compiler/&lt;/code&gt;. The virtual
machine is in &lt;code&gt;vm/&lt;/code&gt;, and the garbage collector is in &lt;code&gt;vm/gc&lt;/code&gt;. As you are
reading through, consider helping us write better documentation. There are
already sections for the &lt;a href=&quot;http://rubini.us/doc/en/virtual-machine/&quot;&gt;virtual
machine&lt;/a&gt;,
&lt;a href=&quot;http://rubini.us/doc/en/garbage-collector/&quot;&gt;garbage-collector&lt;/a&gt;, &lt;a href=&quot;http://rubini.us/doc/en/jit/&quot;&gt;JIT
compiler&lt;/a&gt; and &lt;a href=&quot;http://rubini.us/doc/en/bytecode-compiler/&quot;&gt;bytecode
compiler&lt;/a&gt; in the documentation, so
adding content is easy.&lt;/p&gt;

&lt;p&gt;You may also be interested in these previous posts about Rubinius:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.engineyard.com/blog/2010/rubinius-wants-to-help-you-make-ruby-better/&quot;&gt;Rubinius wants to help YOU make Ruby better&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.engineyard.com/blog/2009/5-things-youll-love-about-rubinius/&quot;&gt;5 Things You'll Love About Rubinius&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.engineyard.com/blog/2009/rubinius-the-book-tour/&quot;&gt;Rubinius: The Book Tour&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Most of all, experiment. Rubinius is easy to hack on. Are you curious about a
particular feature needed in your language? Try adding it to Rubinius. Think
Lua is all the rage because it uses a register VM? You could probably write a
register-based bytecode interpreter for Rubinius in an afternoon. That's just
an example, of course. The point is to play around with your ideas and have
fun doing it. I think you'll find Rubinius to be an adventuresome companion.&lt;/p&gt;

&lt;p&gt;Be sure to let us know what you're working on. We like to be inspired, too!
Consider writing a blog post about things that you find interesing, like this
&lt;a href=&quot;http://yehudakatz.com/2011/02/18/getting-comfortable-with-rubinius-pure-ruby-internals/&quot;&gt;recent post&lt;/a&gt; by Yehuda Katz.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#wur-personas&quot;&gt;&lt;strong&gt;Back to personas&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a class=&quot;anchor_title&quot; name=&quot;wur-conclusion&quot;&gt;Conclusion&lt;/a&gt;&lt;/h3&gt;


&lt;p&gt;So there you have it. Just like there are many different viewpoints, there are
many different reasons to use Rubinius. Not all those reasons make sense to
everyone. We believe, however, that Rubinius has something to offer to just
about everyone interested in Ruby. Most importantly, try it!&lt;/p&gt;

&lt;p&gt;If we didn't answer your question here, leave us a comment. If you have a
reason for using Rubinius that we didn't mention, let us know. As always, we
appreciate your feedback. Chat with us in the #rubinius channel on
freenode.net, &lt;a href=&quot;https://github.com/rubinius/rubinius&quot;&gt;watch our Github project&lt;/a&gt;,
and &lt;a href=&quot;http://twitter.com/rubinius&quot;&gt;follow us on Twitter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;P.S. Thanks to David Waite for suggesting the Academic Researcher and Language
Enthusiast personas, I always forget those!&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Introduction to Fancy</title>
    <id>http://rubini.us/2011/02/23/introduction-to-fancy/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2011/02/23/introduction-to-fancy/" />
    <updated>2011-02-23T00:00:00-06:00</updated>
    <author>
      <name>Christopher Bertels</name>
    </author>
    
    <content type="html">&lt;p&gt;Fancy is a new general-purpose programming language targetting the
Rubinius VM.&lt;/p&gt;

&lt;p&gt;This blog post will give a short introduction to the language, what
kind of problems it's trying to solve and why I chose Rubinius as the
VM to run Fancy on.&lt;/p&gt;

&lt;h3&gt;What is Fancy?&lt;/h3&gt;

&lt;p&gt;Fancy is a new general-purpose, dynamic, pure object-oriented
programming language heavily inspired by Ruby, Smalltalk and Erlang
that runs on the Rubinius VM. It's the first fully bootstrapped
language, aside from Ruby, running on Rubinius. This means that the
compiler that generates bytecode for Rubinius is written in Fancy
itself.&lt;/p&gt;

&lt;p&gt;You can think of Fancy as a mix of features from the mentioned
languages above, taking each of their strengths and improving upon
their weaknesses.
Fancy has a very small core and is largely based on the concept of
message passing, just like Smalltalk. It tries to have as many
language concepts being first-class values in the language.&lt;/p&gt;

&lt;p&gt;Just like Ruby, Fancy is a dynamic object-oriented language that
allows changing code at runtime, everything being an expression and
generally embracing more then one way to do things. Fancy also has all
the literal support that Ruby has, plus literal syntax for Tuples and
Patterns (more on that below).&lt;/p&gt;

&lt;p&gt;In contrast to Ruby and just like Smalltalk, Fancy has a very small
amount of built-in keywords and all of the control structures are
implemented in terms of message sends to objects using closures.&lt;/p&gt;

&lt;p&gt;The third language that served as an inspiration is Erlang, from which
Fancy takes the idea that concurrent programming should be easy by
having the Actor Model built into the language. This part is still a
work in progress, but should come together soon. The fact that
Rubinius has a built-in Channel type, inter-VM communication
capabilities and even an actor library makes implementing this easier
than in traditional systems.&lt;/p&gt;

&lt;h3&gt;Why Fancy?&lt;/h3&gt;

&lt;p&gt;I believe there is real value in having a language that supports
certain things out of the box. Especially when it comes to things like
asynchronous and concurrent programming, having proper semantics built
into the language can often help developers more than a library can.
Very often it's not just about the functionality itself but also about
the semantics you want that functionality to have. This can cause
problems particularly if the language's semantics differ from what
your library is trying to solve. A good example is the callback-based
approach to asynchronous progamming which leads to code that differs
both in semantics as well as how code is structured, compared to
synchronous code. Ideally you'd still want to write code in a
synchronous fashion, where exceptions pop up naturally while still
being highly asynchronous.&lt;/p&gt;

&lt;p&gt;In that sense Fancy is more flexible than Ruby as there's not many
special case semantics built in to the core language. Everything's
done via message passing, which fits nicely the actor model approach
to concurrency. Fancy's syntax is a lot simpler, too.&lt;/p&gt;

&lt;p&gt;Since all the core control structures are just implemented in Fancy
itself and adhere to the message passing protocol, you can easily
override them for your personal needs. This is especially interesting
when implementing domain specific languages.
Say, you'd want to add some logging to conditional or looping
constructs - it's as easy as overriding a method in your DSL's
classes. Fancy also has class-based mixins, so it makes it easy to
share functionality across class hierarchy boundaries.&lt;/p&gt;

&lt;p&gt;Finally, I created Fancy because I wanted a language implementation
that was well documented, easy to understand and very flexible to
extend. Ruby is a nice language, but it has some inconsistencies and
there's only so much you can do when you're bound by backwards
compatibility. By starting fresh, Fancy has a clean, simple and easy
to extend core which allows further exploration of features and
abstractions.&lt;/p&gt;

&lt;h3&gt;Why target Rubinius?&lt;/h3&gt;

&lt;p&gt;The initial implementation of Fancy was a simple interpreter written
in C++, similar to how Ruby 1.8 (MRI) works. It was a simple AST
walker. After moving to Rubinius and writing an initial bootstrap
compiler in Ruby, the codebase shrank to about 20% of the original
implementation while actually being more performant. This of course is
mostly due to Rubinius' architecture and JIT compiler but it was a
great experience nontheless.&lt;/p&gt;

&lt;p&gt;The nice part about having a common virtual machine and runtime is
that you're not forced to a completely different platform to get the
job done. Fancy and Ruby can coexist in the same application nicely
and calling code from one another is dead simple. In fact, as of now,
Rubinius doesn't know anything about Fancy. And it shouldn't. As long
as all languages running on top of it adhere to the same interface
(in this case the bytecode), it should just work fine.&lt;/p&gt;

&lt;p&gt;Choosing Rubinius as a successor platform for Fancy was easy. It's
built for Ruby, a language that's closely related to Fancy. Rubinius,
while having been developed as a VM for running Ruby code, is very
flexible and there are many features that abstract over Ruby's
external semantics. It was just a natural choice given the fact that
Rubinius' architecture and design was heavily influenced by Smalltalk
VMs. Also, it's a very nice dynamic bytecode virtual machine. The
community is very responsive and helpful. Bugs get fixed instantly,
there's always someone to help out and overall it's been a great
experience.&lt;/p&gt;

&lt;h3&gt;Let's look at some code!&lt;/h3&gt;

&lt;p&gt;OK, enough talking. Let's have a look on how to get some Fancy code up
and running. Our little sample application will be a simple IRC bot
that connects to Fancy's irc channel on Freenode and says hello to
everyone that greets it. To make life easier, there's already a Fancy
package out there that helps with exactly this task:
&lt;a href=&quot;https://github.com/bakkdoor/fancy_irc&quot;&gt;FancyIRC&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;FancyIRC is a simple IRC client library inspired by Ruby's IRC bot
framework &lt;a href=&quot;https://github.com/cinchrb/cinch&quot;&gt;Cinch&lt;/a&gt;. It's much simpler
and the code is fairly easy to read, but it gives you a similar
interface for writing IRC clients or bots.&lt;/p&gt;

&lt;p&gt;So let's get going by installing Fancy. You can either use the Fancy
Rubygem and install it with Rubinius or get the code from GitHub and
run &lt;code&gt;rake&lt;/code&gt; in the directory. You'll also then have to add the &lt;code&gt;bin&lt;/code&gt;
directory to your &lt;code&gt;$PATH&lt;/code&gt;. If you want the latest and greatest version
of Fancy I recommend building directly from source, as the Gem might
not be up to date all the time. For demonstration purposes, let's
install the Rubygem.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rbx -S gem install fancy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get the FancyIRC package we use Fancy's built-in package manager,
which knows how to find the code on GitHub and install it locally:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ fancy install bakkdoor/fancy_irc
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;Writing the code&lt;/h4&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-fancy&quot; data-lang=&quot;fancy&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;require:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;fancy_irc&amp;quot;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greeter_bot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;FancyIRC&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Client&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;new:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt;   &lt;span class=&quot;nf&quot;&gt;configuration:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt;     &lt;span class=&quot;nf&quot;&gt;nickname:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;greeter_bot&amp;quot;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt;     &lt;span class=&quot;nf&quot;&gt;server:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;irc.freenode.net&amp;quot;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt;     &lt;span class=&quot;nf&quot;&gt;port:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6667&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt;     &lt;span class=&quot;nf&quot;&gt;channels:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;#fancy&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;# greet person back&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt;   &lt;span class=&quot;nf&quot;&gt;on:&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&amp;#39;channel&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pattern:&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/^[hH]ello greeter_bot/&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;do:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;reply:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;Hello to you too, #{msg author}!&amp;quot;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;# &amp;quot;echo&amp;quot; command&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;# invoke with: !echo &amp;lt;text&amp;gt;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt;   &lt;span class=&quot;nf&quot;&gt;on:&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&amp;#39;channel&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pattern:&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/^!echo (.*)$/&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;do:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;19&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;reply:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;#{msg author} said: #{text}&amp;quot;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;20&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;21&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;22&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;# tell bot to shutdown via !shutdown command&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;23&lt;/span&gt;   &lt;span class=&quot;nf&quot;&gt;on:&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&amp;#39;channel&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pattern:&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/^!shutdown/&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;do:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;24&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;reply:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;OK, shutting down&amp;quot;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;25&lt;/span&gt;     &lt;span class=&quot;no&quot;&gt;System&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;26&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;27&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;28&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;29&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greeter_bot&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;30&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greeter_bot&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I think the code is pretty straight forward. This should give you a
feeling for what Fancy looks and feels like. There is of course lots
more to Fancy than what was shown here. It would not fit into a single
blog post.&lt;/p&gt;

&lt;p&gt;A quick list of what's currently being worked on:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;New pattern matching system: Message passing based pattern matching
that preserves encapsulation and is very extensible including
pattern literals that allow custom pattern types to be defined by
anyone. There's an experimental branch for that. I'm happy
to answer questions.&lt;/li&gt;
&lt;li&gt;Async support using coroutines (Fibers) - Write async code in a more
natural way where exceptions propagate naturally and you don't have
to think about callbacks all the time.&lt;/li&gt;
&lt;li&gt;First-class support for actors - Asynchronous message sends, Futures
and multi-vm messaging built-in.&lt;/li&gt;
&lt;li&gt;And much more...&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Interested?&lt;/h3&gt;

&lt;p&gt;If you got interested in Fancy and want to know where to go next,
here's a short list of things to check out:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/bakkdoor/fancy&quot;&gt;Fancy's GitHub repository&lt;/a&gt;.
The standard library is completely written in Fancy and most classes
and methods have docstrings. It should be fairly easy to understand.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/fancy-lang/infancy&quot;&gt;Programming InFancy&lt;/a&gt;
An open source tutorial on learning Fancy. Work in progress.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://api.fancy-lang.org&quot;&gt;http://api.fancy-lang.org&lt;/a&gt;
A work in progress page containing Fancy's standard library class
and method documentation.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://groups.google.com/forum/#!forum/fancy-lang&quot;&gt;Fancy's Google Group mailinglist&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;IRC Channel: #fancy @ irc.freenode.net&lt;/li&gt;
&lt;li&gt;Website: &lt;a href=&quot;http://www.fancy-lang.org&quot;&gt;http://www.fancy-lang.org&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
  </entry>
  
  <entry>
    <title type="html">Running Multiple Rubinius Branches Simultaneously with RVM.</title>
    <id>http://rubini.us/2011/02/22/rubinius-multiple-branches-with-rvm/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2011/02/22/rubinius-multiple-branches-with-rvm/" />
    <updated>2011-02-22T00:00:00-06:00</updated>
    <author>
      <name>Wayne E. Seguin</name>
    </author>
    
    <content type="html">&lt;p&gt;This article is written with the assumption that you have RVM installed
already. If you do not, follow the
&lt;a href=&quot;https://rvm.beginrescueend.com/rvm/install/&quot;&gt;Installation Instructions&lt;/a&gt;
followed by the
&lt;a href=&quot;https://rvm.beginrescueend.com/rvm/basics/&quot;&gt;Basics&lt;/a&gt;
closely first.&lt;/p&gt;

&lt;h3&gt;Named Ruby Installs&lt;/h3&gt;

&lt;p&gt;Everyone familiar with RVM knows that it allows you to quickly and
easily install a particular Ruby interpreter by simply running, for
example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rvm install rbx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What is not widely known (yet) is that there is a &quot;Named Rubies&quot; feature
that allows you to install altered versions of the same Ruby
installation along side the original.&lt;/p&gt;

&lt;p&gt;In the case of Rubinius there is this facinating branch called 'hydra'.
So let us see how we can have the Rubinius master branch installed as
the main rbx with the hydra branch installed along side as well.&lt;/p&gt;

&lt;p&gt;As above you first install rbx which is currently defaulted to -head
version so&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rvm install rbx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is currently equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rvm install rbx-head
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After we have the mainline head Rubinus branch installed, we now want to
use the named rubies feature. This is done using the -n specifier in the
Ruby identifier string. So for example to install our hydra branch as an
RVM ruby with the name 'hydra' in it we do the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rvm install --branch hydra rbx-nhydra
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can see that they can be used together! Using the Rubinius master
environment,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rvm rbx ; ruby -v
rubinius 1.2.1 (1.8.7 6feb585f 2011-02-15 JI) [x86_64-apple-darwin10.6.0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whereas using the Rubinius hydra environment,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rvm rbx-nhydra ; ruby -v
rubinius 1.3.0dev (1.8.7 6feb585f xxxx-xx-xx JI) [x86_64-apple-darwin10.6.0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We see that the next release of Rubinius (hydra branch) is indeed
version 1.3.0 whereas the master branch is version 1.2.1.&lt;/p&gt;

&lt;p&gt;Also please note that RVM creates wrapper scripts, so you do not need to
switch out the entire environment just to run the differen versions
either:&lt;/p&gt;

&lt;p&gt;For Rubinius master,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rbx-head -v
rubinius 1.2.1 (1.8.7 6feb585f 2011-02-15 JI) [x86_64-apple-darwin10.6.0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For Rubinius hydra,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rbx-head-nhydra -v
rubinius 1.3.0dev (1.8.7 6feb585f xxxx-xx-xx JI) [x86_64-apple-darwin10.6.0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is a lot more available to you than this, for more information on
RVM capabilities please visit the &lt;a href=&quot;https://rvm.beginrescueend.com/&quot;&gt;RVM
Website&lt;/a&gt; and also come talk to us in #rvm on
irc.freenode.net during the daytime EDT.&lt;/p&gt;

&lt;p&gt;I hope that this is helpful and informative to you!&lt;/p&gt;

&lt;p&gt;  ~Wayne&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Rubinius, What's Next?</title>
    <id>http://rubini.us/2011/02/17/rubinius-what-s-next/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2011/02/17/rubinius-what-s-next/" />
    <updated>2011-02-17T00:00:00-06:00</updated>
    <author>
      <name>Brian Ford</name>
    </author>
    
    <content type="html">&lt;p&gt;On Tuesday, we released version 1.2.1 (see the &lt;a href=&quot;http://rubini.us/releases/1.2.1/&quot;&gt;Release
notes&lt;/a&gt;). This release weighs in at 256
commits and 21 tickets closed in the 56 calendar days since the release of
1.2.0. Many thanks to those who contributed patches and to everyone who helped
us test it.&lt;/p&gt;

&lt;p&gt;While we were working on 1.2.1, we were also working on a Top Secret project
that we've craftily &lt;a href=&quot;https://github.com/evanphx/rubinius/tree/hydra&quot;&gt;hidden in plain
sight&lt;/a&gt;. I'd like to introduce
the work we are doing on the hydra branch and the features you can expect to
see in Rubinius soon.&lt;/p&gt;

&lt;h3&gt;Daedalus - A new build system&lt;/h3&gt;

&lt;p&gt;Rubinius is a fairly complex project. It combines multiple components into a
single system. We have worked hard to contain this complexity and from the
beginning we insisted that building Rubinius be as simple as possible. For
example, Rubinius can be run from the source directory, there is no need to
install it first. Typically, building requires:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./configure
rake
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Rubinius system combines:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;External libraries written in C/C++, sometimes built with just Makefiles
and sometimes using autotools.&lt;/li&gt;
&lt;li&gt;The virtual machine, garbage collector, and JIT compiler written in C++.&lt;/li&gt;
&lt;li&gt;The virtual machine interpreter instructions, including support code for
the JIT, and instruction documentation all generated at build time from an
instruction template.&lt;/li&gt;
&lt;li&gt;The core library and bytecode compiler written in Ruby.&lt;/li&gt;
&lt;li&gt;Various C extensions like the Melbourne parser, BigDecimal, Digest, and
OpenSSL libraries. In the case of the parser, we have to build &lt;em&gt;two&lt;/em&gt;
versions, one for the bootstrapping system and one for the Rubinius system
being built.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;It has not been easy to make this work and over the years we have compiled a
list of exactly what we need in a build system. Evan, in typical form, started
hacking out a first pass and created &lt;em&gt;daedalus&lt;/em&gt;, our new build system. It
features such exotic (and extremely useful) features as SHA-based change
detection, parallel builds, single-process execution, and use-aware
configuration options. Allow me to elaborate.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A typical build system decides to rebuild a file if the source is newer than
the build artifact. This can result is unnecessarily building files that
have been touched by some process (like updating from the source repository)
but whose contents have not changed.  By basing rebuild decisions on the SHA
digest of the source, only files that have actually been changed need to be
built. Since compiling C++ with optimizations is &lt;em&gt;not&lt;/em&gt; a fast process,
eliminating unnecessary building is great for productivity, not to mention
global warming.&lt;/li&gt;
&lt;li&gt;With a multi-core system, builds can be done faster if they are done in
parallel. If the build system can accurately determine dependencies, it can
execute build sub-steps in parallel. Of course, this can cut into YouTube
and Twitter browsing time, but that's a risk we are willing to take.&lt;/li&gt;
&lt;li&gt;While parallel sub-processes during the build are excellent, the supervising
process benefits from running as a single process from start to finish.
Otherwise, configuration data needs to be re-parsed. To support a single
build process, we need multiple, independent dependency graphs for the
components. As noted above, we need to build two versions of the parser,
which requires two dependency graphs &lt;em&gt;for the same component&lt;/em&gt;! This is
simply impossible in Rake.&lt;/li&gt;
&lt;li&gt;Use-aware configuration values know that the user has set the value and can
intelligently merge with newer configuration variables that we create
without requiring the user to reconfigure. Ultimately, we are aiming for a
&lt;em&gt;single&lt;/em&gt; command build. Just run 'daedalus' and done. There is no step 2.&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Full-on Concurrency&lt;/h3&gt;

&lt;p&gt;Nobody likes waiting in line. In fact, the more desirable a thing is, the less
we want to stand idly waiting in a line for it, tapping our foot, twiddling
our thumbs. The same could be said about our programs.&lt;/p&gt;

&lt;p&gt;Threads give us the ability to add concurrency to our programs. However,
unless the hardware either has multiple CPUs or multiple cores per CPU (or
both), the apparent concurrency will still be executing serially. Since there
are so many multi-core CPUs around these days, our programs should be getting
stuff done in parallel.&lt;/p&gt;

&lt;p&gt;Unfortunately, there's a twist. Even with native threads on a multi-core CPU,
the amount of parallelism you get depends on how well you manage locks around
shared data and resources. Sometimes managing these locks is complex and you
opt for one big lock, essentially only allowing one thread at a time to run.
That big lock is usually called a global interpreter lock (GIL) or global VM
lock (GVL).&lt;/p&gt;

&lt;p&gt;The Rubinius VM originally had green (user-space) threads, but it has had
native threads with a GIL for a while now. In the hydra branch, Evan and
contributors like Dirkjan Bussink have been working on replacing the GIL with
fine-grained locks so that threads truly execute in parallel. This work has
been going very well, owing in part to the fact that so much code in Rubinius
is actually written in Ruby. Contributors like Chuck Remes have been running
hydra under heavy concurrency loads and Rubinius is performing well.&lt;/p&gt;

&lt;p&gt;Rubinius also has experimental support for Fibers and a built-in Actor
library. There is more work to be done but Rubinius is quickly becoming an
excellent platform for concurrency, with a variety of approaches available to
the programmer. Evan has also suggested rewriting the Rubinius IO subsystem to
enable even better APIs for concurrency, all from Ruby.&lt;/p&gt;

&lt;h3&gt;Performance&lt;/h3&gt;

&lt;p&gt;Forget everything anyone has ever told you about Ruby being slow. There are
two things that make Ruby, as implemented, slow: 1) inexperience; 2)
inadequate tools. These two result in one big thing: &lt;em&gt;doing too much&lt;/em&gt;. Or, as
they say: &lt;em&gt;No code runs faster than no code&lt;/em&gt;. We have been working for 4+
years to build adequate tools in Rubinius, and there is plenty of experience
in Smalltalk, Self, and other languages for making dynamic languages fast.&lt;/p&gt;

&lt;p&gt;Presently, Rubinius typically runs pure Ruby code almost 2 times faster than
MRI 1.9. However, there are also cases where Rubinius is slower. These mostly
involve core libraries that are implemented in C in MRI. There are three main
fronts on which we are attacking performance issues: 1) improving the
algorithms in the Ruby code that implements the core library; 2) continuing to
tune the VM and garbage collector; and 3) improving the JIT compiler. Which
leads me to one of the most exciting things we are working on...&lt;/p&gt;

&lt;h3&gt;JIT Intermediate Representation (IR)&lt;/h3&gt;

&lt;p&gt;The just-in-time (JIT) compiler is the key to making Ruby fast. One of the
biggest challenges with a dynamic language like Ruby is knowing what method is
actually being invoked when a message is sent to an object. Consider the
following code:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;B&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;C&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;work&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;What method is being invoked by &lt;code&gt;obj.m(y)&lt;/code&gt;? There is no way to definitively
know this by looking at the source code. However, when the program is actually
running, we can know precisely what &lt;code&gt;obj&lt;/code&gt; is and precisely which method &lt;code&gt;m&lt;/code&gt;
was invoked. This is called type profiling and that is exactly what the Rubinius
VM does. Then the JIT uses the type information to make decisions like whether
to inline a method into another method. When methods are inlined, it gives the
optimizer more data and more possibilities to remove redundant code. The less
code we can run, the faster Ruby will be.&lt;/p&gt;

&lt;p&gt;Presently, the JIT compiler converts Rubinius bytecode into LLVM IR and LLVM
handles the thorny task of generating machine code. However, Rubinius bytecode
is designed for fast execution by the virtual machine rather than as a rich
intermediate representation. So Evan has started work on a new JIT IR.&lt;/p&gt;

&lt;p&gt;This new IR will help us to express Ruby semantics in a way that enables many
powerful optimizations and will ultimately allow LLVM to generate even better
machine code. Put another way, &lt;em&gt;Rubinius loves Ruby code!&lt;/em&gt; Right down to the
metal. There's no fighting a foreign type system or the semantics of a
language at odds with Ruby's rosy view of the world.&lt;/p&gt;

&lt;h3&gt;Ruby 1.9&lt;/h3&gt;

&lt;p&gt;MRI 1.9 introduced two completely different changes to Ruby. The first was a
new implementation based on a bytecode virtual machine. While the virtual
machine replaced the AST-walking interpreter, little else changed
architecturally. Mostly the same core library and garbage collector code
exists in MRI 1.9 as was in MRI 1.8. The second change introduced some new
syntax (minor) and encodings (major). Many of the other changes, for example,
returning Enumerator objects from methods that take blocks, have been
back-ported to Ruby 1.8.7 and are already available in Rubinius.&lt;/p&gt;

&lt;p&gt;So, the key to supporting Ruby 1.9 in Rubinius essentially involves supporting
the 1.9 syntax changes and encodings. We have begun implementing the parser
changes and introduced the foundation for Encoding-aware Strings. A good
amount of work remains to be done, but over the next month we expect that
we will be starting to run Ruby 1.9-specific code in Rubinius.&lt;/p&gt;

&lt;h3&gt;Tools of Information&lt;/h3&gt;

&lt;p&gt;It has been said that &lt;code&gt;printf&lt;/code&gt; is the mother of all debuggers. That
illustrates two points: 1) data is often buried in our program code; and 2) we
should have tools (e.g. a debugger) that enables us to access the data without
manually instrumenting our code.&lt;/p&gt;

&lt;p&gt;Presently, Rubinius has a built-in debugger, precise method profiler, memory
analysis tool, and Agent interface that permits querying a running Rubinius
VM--even one running on a remote machine--for a variety of information.&lt;/p&gt;

&lt;p&gt;We will be adding the ability to track the location where objects are
allocated to assist finding object leaks or code that is creating unusually
large numbers of objects. We are also working on a tool to graphically display
information like number of running threads, amount of CPU usage, and amount of
memory used while actively monitoring a VM.&lt;/p&gt;

&lt;p&gt;I am also curious about correlating this VM information with external data to
enable play-back review.  For example, I would like to monitor RubySpec runs
and correlate which spec is running with the VM data. I imagine a simple
monotonic reference ID provided by the VM would be useful in correlating these
two otherwise unrelated pieces of data. The RubySpec runner would request the
ID before running each spec and the Agent monitor would request the ID when
gathering VM data. Later the two data sets could easily be merged.&lt;/p&gt;

&lt;p&gt;When you find yourself manually instrumenting some code, consider what data
you are trying to get your hands on and let us know the scenario.  We'll
likely be able to build a tool that will open up new vistas into the behavior
of your Ruby programs.&lt;/p&gt;

&lt;h3&gt;Windows&lt;sup&gt;&amp;reg;&lt;/sup&gt;&lt;/h3&gt;

&lt;p&gt;However one may feel about Windows as an operating system, it is undeniable
that the vast majority of people in the world use Windows. We believe those
people have an inalienable right to use Rubinius, too.&lt;/p&gt;

&lt;p&gt;Thanks to the wonderful, hard-working
&lt;a href=&quot;http://mingw-w64.sourceforge.net/&quot;&gt;MinGW-w64&lt;/a&gt; folks, we are able to compile
the Rubinius VM into a native Windows executable. Presently, the VM will
compile, link, and attempt to load the Ruby core library. More
platform-specific work is needed to load the library. The next step after that
will be getting the RubySpecs to run and start fixing issues.&lt;/p&gt;

&lt;p&gt;Since the Windows work is being done on the hydra branch, the other features
discussed above will be available on Windows as soon as we complete them.&lt;/p&gt;

&lt;h3&gt;Multi-language-ualization&lt;/h3&gt;

&lt;p&gt;The Rubinius VM began as an effort to create a modern, first-class environment
for running programs written in Ruby. However, it turns out that Ruby is a
terrific language for writing subsystems for other programming languages.
Actually, this should come as no surprise; Ruby is a fabulous general purpose
programming language.&lt;/p&gt;

&lt;p&gt;To support experimenting with writing other languages that run on the Rubinius
VM, Evan has started to put together a Language Toolkit. This includes things
like a built-in PEG parser, convenient ways to create methods from Rubinius
bytecode, and decoupling method dispatch from Ruby semantics.&lt;/p&gt;

&lt;p&gt;Hopefully, Evan will introduce us to all this in a future blog post, but
here is a taste of what you can do:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Hello&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;dynamic_method&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:world&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:self&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_literal&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;Hello, world&amp;quot;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:puts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Hello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;world&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Of course, that is much more concisely written in Ruby, but combine this
ability with a built-in PEG parser and you can be experimenting with your own
fascinating syntax in a matter of minutes.&lt;/p&gt;

&lt;p&gt;Check out the Rubinius &lt;a href=&quot;http://rubini.us/projects/&quot;&gt;Projects page&lt;/a&gt; for some of
these language experiments. One language in particular is
&lt;a href=&quot;https://github.com/bakkdoor/fancy&quot;&gt;Fancy&lt;/a&gt;, which is fully bootstrapped (i.e.
the Fancy compiler is now written in Fancy) on Rubinius.&lt;/p&gt;

&lt;h3&gt;Documentation&lt;/h3&gt;

&lt;p&gt;One the one hand, Rubinius just runs Ruby code, and you shouldn't need any
special knowledge to run your application on Rubinius. On the other hand, as
I've discussed above, there are some specific Rubinius features that may be
very helpful to you. However, they can only be as helpful as the documentation
we have for them.&lt;/p&gt;

&lt;p&gt;Before we released 1.2.0 in December last year, I spent quite a bit of time
getting a new documentation system in place. Since then, we've had
contributors help with translations to Russian, Polish, Spanish, and German.
Adam Gardiner started documenting the garbage collector algorithms. Yehuda
Katz (you may have heard the name) has contributed documentation for &lt;a href=&quot;http://rubini.us/doc/en/bytecode-compiler/&quot;&gt;the
bytecode compiler&lt;/a&gt; complete with
diagrams!. Chuck Remes wrote up a great piece on the &lt;a href=&quot;http://rubini.us/doc/en/tools/memory-analysis/&quot;&gt;memory
analysis&lt;/a&gt; tool.&lt;/p&gt;

&lt;p&gt;We really appreciate these contributions. We understand the need for great
documentation and we have been creating better support for it. In many cases,
all that is needed is to just open a file and start writing. Of course, one
cannot expect to understand much about Rubinius without digging into the code.
If there is a particular part of Rubinius that you are curious about, jump in
the #rubinius channel on freenode.net and ask us questions. We can point you
in the right direction and help clarify things. If nothing else, let us know
which part of the missing documentation is most important to you and we can
start filling that in.&lt;/p&gt;

&lt;h3&gt;How you can help&lt;/h3&gt;

&lt;p&gt;There you have it, some super exciting things coming very soon for Rubinius
and for Ruby! We would love to have your help making Rubinius even better. The
most important thing you can do is try running your Ruby code. Give us
feedback. Let us know what features or tools would make your life easier. Help
us to build them.&lt;/p&gt;

&lt;p&gt;Rubinius adopts Ruby's rosy view of the world. We want to empower you to solve
your hardest problems with Ruby, and have fun doing it.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title type="html">Rubinius Has a Blog!</title>
    <id>http://rubini.us/2010/12/15/rubinius-has-a-blog/</id>
    <link rel="alternate" type="text/html" href="http://rubini.us/2010/12/15/rubinius-has-a-blog/" />
    <updated>2010-12-15T00:00:00-06:00</updated>
    <author>
      <name>Brian Ford</name>
    </author>
    
    <content type="html">&lt;p&gt;Many thought the day would never come, but Rubinius finally has a blog. That's
not all, though: We have integrated the website, blog, and documentation using
Jekyll. The source code for it all is in the main &lt;a href=&quot;http://github.com/rubinius/rubinius&quot;&gt;Rubinius
repository&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;People have often requested that we write more about the &lt;em&gt;awesome&lt;/em&gt; features in
Rubinius. We hear you and we'd love to do this. However, there is always a
trade-off between working on those awesome features and writing about them.
Until now, it's been rather painful to write docs or blog posts because we did
not have good infrastructure in place. Now, I think we do. I'm sure there are
still a lot of improvements we can make, but we have a good place to start.
I'd like to give a brief tour of our new system.&lt;/p&gt;

&lt;p&gt;The primary goal was to improve collaboration and reduce friction for writing
new documentation and blog posts. That's right, improve collaboration. There
are many people who have experience developing Rubinius and running their
applications on it. We love how people have collaborated with source code
commits. Now anyone has the ability to write a blog post as well. I've written
a basic &lt;a href=&quot;/doc/en/how-to/write-a-blog-post/&quot;&gt;How-To - Write a Blog Post&lt;/a&gt;
document. If you have an idea for a blog post, just let us know. We will
exercise a bit of editorial control just to ensure the topics are appropriate
for Rubinius, but generally, we are thrilled to have your contributions.&lt;/p&gt;

&lt;p&gt;Recently, we added the &lt;code&gt;rbx docs&lt;/code&gt; command. This will run a web server on your
machine and open a browser window to display the Rubinius documentation. Now
the documentation will also be available at the &lt;a href=&quot;http://rubini.us&quot;&gt;rubini.us&lt;/a&gt;
website. I have added a basic outline and a bunch of files to further simplify
the task of writing docs. In many cases, merely open a file and start writing
docs in &lt;a href=&quot;http://daringfireball.net/projects/markdown/syntax&quot;&gt;Markdown&lt;/a&gt; format.&lt;/p&gt;

&lt;p&gt;We have also begun translating our documentation to other languages. I am
excited about this, being a huge language geek. I wish that I were proficient
in 10 languages so I could polish our documentation for the many people who
are not native English speakers. Alas, I only have a fair ability to write in
Spanish, so we are again depending on your help. I started the translation
effort by passing the existing English docs through Google translate. We have
a beginning guide for &lt;a href=&quot;/doc/en/how-to/translate-documentation&quot;&gt;How-To - Translate
Documentation&lt;/a&gt;. I've been told by
&lt;em&gt;kronos_vano&lt;/em&gt; in our #rubinius IRC channel that he's already working on a
Russian translation. I personally would love to see Japanese and Chinese
translations.&lt;/p&gt;

&lt;p&gt;So that's a brief introduction to our new infrastructure for documenting and
explaining Rubinius. It's been such a joy to see so many people contribute to
the Rubinius source code over the years. We hope that the blog, documentation,
and translations will further empower people to contribute and benefit from
the value that Rubinius has to offer the Ruby community.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Adelante!&lt;/em&gt;&lt;/p&gt;
</content>
  </entry>
  

</feed>
